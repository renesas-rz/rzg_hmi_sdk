{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#hmi-sdk-on-rzg-series","title":"HMI SDK on RZ/G series","text":"<p>The Renesas RZ/G HMI SDK is an all-in-one package that includes the necessary software for developing a Linux HMI application.</p> <p>The HMI SDK provides a Linux HMI application development environment for the RZ/G Evaluation Board Kit.</p> <ul> <li> <p>Easy-to-Use</p> <p>The HMI SDK provides a quick and easy development environment, making it easier for Linux beginners to start using a Linux MPU.</p> </li> <li> <p>Free of Charge</p> <p>All software in the HMI SDK is available for free.</p> </li> <li> <p>Ready-to-Use</p> <p>The HMI SDK includes the following GUI frameworks and libraries that are appropriate for HMI.</p> <ul> <li>LVGL (Light and Versatile Graphics Library), which is a lightweight, free, open-source embedded graphics library.</li> <li>Chromium, which is a free and browser-based framework for application programs with GPU.</li> </ul> </li> </ul> <p> </p> <p>By using the image files from the SDK, you can easily create a bootable SD card. Insert the SD card into the board, and the HMI demo will automatically start on Linux. You can then begin developing your own application with ease, as the SDK includes an installer for a cross-development toolchain. Additionally, sample applications that run on the HMI SDK Linux environment are available on our GitHub.</p> <p>For more information, see Overview.</p>"},{"location":"#whats-new","title":"What's new","text":"<p>2025/08/07</p> <p>RZ/G HMI SDK version 2.3.1.0 is available.</p> <ul> <li>Update VLP/G from v3.0.6 update3 to v3.0.7.</li> <li>Update RZ MPU HTML5 (Chromium) Package for VLP from v1.0.0 to v1.0.1<ul> <li>Add support for hardware video decoding on Chromium (RZ/G2L only).</li> </ul> </li> <li>Add a video player to home panel demo running on Chromium (RZ/G2L only).</li> <li>Add a sample application program \u2019LVGL home panel demo\u2019.</li> </ul> <p>View Version History &gt;</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Getting Started is a complete guide to learn how to run HMI Applications, which explains the procedure for setting up the development environment, compiling HMI Applications, setting up the board and running HMI Applications.</p> <p>Get your target board now and GET STARTED.</p>"},{"location":"#hmi-frameworks","title":"HMI Frameworks","text":"<p>The HMI SDK supports the following GUI frameworks and libraries that are appropriate for HMI. In addition, the HMI SDK provides HMI sample applications implemented by using the GUI frameworks and libraries. For more information about the applications, see Overview.</p>"},{"location":"#lvgl-light-and-versatile-graphics-library","title":"LVGL (Light and Versatile Graphics Library)","text":"<p>LVGL is the most popular free and open-source embedded graphics library to create beautiful UIs for any MCU, MPU and display type. It is a lightweight graphics library, and it works without GPU. In addition, a lot of sample applications are available. They would be helpful to users.</p>"},{"location":"#chromium","title":"Chromium","text":"<p>Chromium is the most popular browser in recent years, and it is increasingly being adopted for embedded products. You can implement HTML5-based solutions using Chromium. It uses GPU for its rendering.</p> <p>A browser-based GUI on Chromium (HTML5 solutions) offers several advantages:</p> <ul> <li>Feature-rich user interface</li> <li>Cross-platform compatibility</li> <li>Lower development costs</li> </ul>"},{"location":"#video","title":"Video","text":"<ul> <li> <p> RZ/G2L Tutorial: Get Started with HMI SDK This video introduces the Renesas HMI SDK, then guides you through accessing its website and downloading the package.  It concludes with a brief demonstration on how to quickly deploy it.</p> </li> <li> <p> RZ/G2L Advanced Tutorial: Build the HMI SDK Sample Application Learn how to build the HMI SDK sample application with this step-by-step tutorial.  The video will also cover deploying and running the sample application.</p> </li> <li> <p> 64-bit RZ/G2L, RZ/G2LC Microprocessors Expand HMI Features</p> </li> </ul>"},{"location":"download/","title":"Board and Software","text":""},{"location":"download/#board-and-software","title":"Board and Software","text":"<p>HMI SDK provides the following packages:</p> <ul> <li> <p>eSD boot image and toolchain installer package</p> <p>This package is the heart of HMI SDK. You can create a bootable microSD card, set up Linux environment on the EVK, and build sample applications.</p> </li> <li> <p>Yocto recipe and pre-built binary image package</p> <p>This is an optional package. If you would like to build the HMI SDK from scratch, or you would like to try QSPI boot or eMMC boot (other than eSD boot mode), get this package.</p> </li> <li> <p>Source code package</p> <p>When you build the HMI SDK from scratch, you can use source code in this package for offline building.</p> </li> </ul> <p>Except for the source code package, the packages are available for each EVK.</p>"},{"location":"download/#rzg2l-evaluation-board-kit-evk","title":"RZ/G2L Evaluation Board Kit (EVK)","text":"<p> Get RZ/G2L EVK</p> <p> Get HMI SDK for RZ/G2L EVKeSD boot image and toolchain installer package</p> <p> Get HMI SDK for RZ/G2L EVKYocto recipe and pre-built binary image package</p> <p> Get HMI SDKSource code package</p>"},{"location":"download/#rzg2lc-evaluation-board-kit-evk","title":"RZ/G2LC Evaluation Board Kit (EVK)","text":"<p> Get RZ/G2LC EVK</p> <p> Get HMI SDK for RZ/G2LC EVKeSD boot image and toolchain installer package</p> <p> Get HMI SDK for RZ/G2LC EVKYocto recipe and pre-built binary image package</p> <p> Get HMI SDKSource code package</p>"},{"location":"download/#rzg2ul-evaluation-board-kit-evk","title":"RZ/G2UL Evaluation Board Kit (EVK)","text":"<p> Get RZ/G2UL EVK</p> <p> Get HMI SDK for RZ/G2UL EVKeSD boot image and toolchain installer package</p> <p> Get HMI SDK for RZ/G2UL EVKYocto recipe and pre-built binary image package</p> <p> Get HMI SDKSource code package</p> <p>Back to Home &gt; Back to Getting Started &gt;</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#faq","title":"FAQ","text":"<p>If you have any questions about the HMI SDK, please do not hesitate to raise an issue at our Repository Issues.</p> <p>If your questions are common in RZ/G and/or RZ MPU Linux, you may have answers on the following websites.</p> <ul> <li> <p>Renesas \u3088\u304f\u3042\u308b\u3054\u8cea\u554f (FAQ) | Knowledge Base (FAQ's) | \u77e5\u8bc6\u5e93 website</p> <ul> <li>[JP] RZ/G</li> <li>[EN] RZ/G</li> <li>[CN] RZ/G</li> </ul> </li> <li> <p>Renesas Engineering Community website</p> <ul> <li>[JP] RZ MPU</li> <li>[EN] Microprocessors (RZ)</li> <li>[CN] RZ MPU</li> </ul> </li> <li> <p>Renesas Wiki's: RZ/G</p> </li> </ul>"},{"location":"faq/#q-what-is-the-difference-between-vlp-and-hmi-sdk","title":"Q. What is the difference between VLP and HMI SDK?","text":"<p>Please see the figure below.  The left diagram in the figure shows the development method without the HMI SDK. Users need to download and integrate necessary software packages such as VLP (Verified Linux Package), graphics library, codec library, and HMI framework or libraries. The right diagram in the figure shows the development method with the HMI SDK. The HMI SDK is provided as an 'all-in-one package'. Users do NOT need to look for appropriate software and worry about how to integrate all modules.</p> <p>For information about VLP, please visit the website RZ/G Software Package.</p>"},{"location":"faq/#q-what-rules-does-hmi-sdk-version-numbering-follow","title":"Q. What rules does HMI SDK version numbering follow?","text":"<p>The version number of the HMI SDK consists of four numbers.</p> <ul> <li>Version W.X.Y.Z<ul> <li>W = This number is updated when we add new application frameworks or update existing frameworks.</li> <li>X = This number is linked to the major version number of VLP.</li> <li>Y = This number is updated when we make semi-annual VLP updates, add device support, and make minor updates in frameworks. </li> <li>Z = This number is updated when we fix bugs.</li> </ul> </li> </ul> <p>This rule was effective from December 27, 2024.</p>"},{"location":"faq/#q-does-the-chromium-included-in-hmi-sdk-v2300-support-hardware-decoding","title":"Q. Does the Chromium included in HMI SDK v2.3.0.0 support hardware decoding?","text":"<p>The Chromium included in HMI SDK v2.3.0.0 does not support hardware-accelerated video playback using HW codecs.  However, Chromium in HMI SDK v2.3.1.0 is now offering hardware-accelerated video playback. Graphics rendering in Chromium utilizes hardware acceleration. </p>"},{"location":"faq/#q-in-the-chromium-home-panel-demo-the-seek-bar-in-the-video-player-doesnt-seem-to-be-working","title":"Q. In the Chromium Home Panel Demo, the seek bar in the video player doesn't seem to be working.","text":"<p>Please refresh the browser and try again.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#getting-started","title":"Getting Started","text":"<p>This page explains how to start-up the HMI SDK.</p> <p>Notice</p> <p>Several updated OSS components, aimed at addressing vulnerabilities and improving drivers, have been published on Renesas' GitHub. Please refer to Update Linux Package in HMI SDK for instructions on how to replace them.</p>"},{"location":"getting_started/#introduction","title":"Introduction","text":"<p>Getting Started explains the instruction to run HMI Applications.</p> <p>Common instructions are explained in this document.</p>"},{"location":"getting_started/#step-1-obtain-an-evaluation-board","title":"Step 1: Obtain an evaluation board","text":"<p>Click the button below to get the board.</p> <p>Board and SoftwareGet the board and software for RZ/G series.</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p> <p>The RZ/G2L Evaluation Board Kit (EVK) is the ideal board kit for RZ/G2L evaluation.</p> <p>Following items are included in the RZ/G2L Evaluation Board Kit.</p> Equipment Details RZ/G2L Evaluation Board Evaluation board itself Micro USB to Serial Cable For serial communication between PC and the board <p></p> <p>The RZ/G2LC Evaluation Board Kit (EVK) is the ideal board kit for RZ/G2LC evaluation.</p> <p>Following items are included in the RZ/G2LC Evaluation Board Kit.</p> Equipment Details RZ/G2LC Evaluation Board Evaluation board itself Micro USB to Serial Cable For serial communication between PC and the board <p></p> <p>The RZ/G2UL Evaluation Board Kit (EVK) is the ideal board kit for RZ/G2UL evaluation.</p> <p>Following items are included in the RZ/G2UL Evaluation Board Kit.</p> Equipment Details RZ/G2UL Evaluation Board Evaluation board itself Micro USB to Serial Cable For serial communication between PC and the board Parallel to HDMI Conversion Board For convert display output from Parallel to HDMI"},{"location":"getting_started/#step-2-obtain-necessary-environment","title":"Step 2: Obtain necessary environment","text":""},{"location":"getting_started/#1-necessary-equipment","title":"1. Necessary Equipment","text":"<p>Please prepare the following equipment for your EVK.</p> RZ/G2LRZ/G2LCRZ/G2UL <p>Equipment</p> <p>Purpose</p> <p>Remarks</p> <p>RZ/G2L Module Board (SMARC2.1) + Common Carrier Board  (P/N: RTK9744L23S01000BE) </p> <p>It is used to evaluate not only Linux but also demo programs or applications that run on Linux in the Linux operating environment provided by HMI SDK.  4GB or more ROM (SPI or eMMC or SD)  2GB or more RAM (DDR4/DDR3L 16bit x 1.6/1.3Gbps)</p> <p>Included with RZ/G2L Evaluation Board Kit (EVK) </p> <p>USB serial cable </p> <p>It is used to connect the PC and the EVK and get the console output of Linux running on the EVK.  * Connect to micro USB type-B (2.0) port of EVK</p> <p>Included with RZ/G2L Evaluation Board Kit (EVK) </p> <p>USB Power Delivery (PD) AC adapter + USB C PD cable for power supply </p> <p>Used for power supply  * Connect to USB type-C port of EVK</p> <p>PC </p> <p>It can be used to operate the demo environment from a terminal on a PC, rebuild HMI SDK Linux, or use it as a development device for applications.  At least 100GB or more free space of HDD/SDD  8GB or more RAM * 4-core or more CPU</p> <p>The OS of the PC is as follows. However, Windows PCs are for debugging using a serial connection and cannot be used for development such as building software.  Ubuntu 22.04 LTS, 64-bit version  Windows 10 or 11 </p> <p>HDMI display monitor + HDMI cable </p> <p>Used to display demo programs or applications provided by HMI SDK.  * Connect to micro HDMI port of EVK </p> <p>If you need a touch panel function, you need a panel that supports USB connection.  The HMI SDK supports the display of resolutions supported by the Extended Display Identification Data (EDID) information obtained from this HDMI display monitor.</p> <p>USB mouse </p> <p>Used to operate demo programs and applications provided by HMI SDK.  * USB HID Compliant</p> <p>USB hub </p> <p>Used when multiple USB devices are required for the demo program or applications provided by HMI SDK.</p> <p>USB keyboard </p> <p>Used to operate demo programs and applications provided by HMI SDK.  * USB HID Compliant</p> <p>USB touch screen </p> <p>Used to operate demo programs and applications provided by HMI SDK.  * USB HID Compliant</p> <p>USB camera </p> <p>Used to evaluate camera input in applications provided by HMI SDK.  * UVC Compliant</p> <p>Audio speaker </p> <p>Used to evaluate the audio output demo programs or applications provided by HMI SDK.  * 3.5mm mini plug connector required</p> <p>micro SD card </p> <p>Linux and demo images provided by the HMI SDK are written and used as a Linux boot device.  Type: SDHC  Speed class: UHI-Class 10 * Capacity: Minimum 4GB, recommended 8GB</p> <p>Linux on the RZ/G2L EVK is booted from a micro SD card by eSD boot. </p> <p>Equipment</p> <p>Purpose</p> <p>Remarks</p> <p>RZ/G2LC Module Board (SMARC2.1) + Common Carrier Board  (P/N: RTK9744C22S01000BE) </p> <p>It is used to evaluate not only Linux but also demo programs or applications that run on Linux in the Linux operating environment provided by HMI SDK.  4GB or more ROM (SPI or eMMC or SD)  1GB or more RAM (DDR4/DDR3L 16bit x 1.6/1.3Gbps)</p> <p>Included with RZ/G2LC Evaluation Board Kit (EVK) </p> <p>USB serial cable </p> <p>It is used to connect the PC and the EVK and get the console output of Linux running on the EVK.  * Connect to micro USB type-B (2.0) port of EVK</p> <p>Included with RZ/G2LC Evaluation Board Kit (EVK) </p> <p>USB Power Delivery (PD) AC adapter + USB C PD cable for power supply </p> <p>Used for power supply  * Connect to USB type-C port of EVK</p> <p>PC </p> <p>It can be used to operate the demo environment from a terminal on a PC, rebuild HMI SDK Linux, or use it as a development device for applications.  At least 100GB or more free space of HDD/SDD  8GB or more RAM * 4-core or more CPU</p> <p>The OS of the PC is as follows. However, Windows PCs are for debugging using a serial connection and cannot be used for development such as building software.  Ubuntu 22.04 LTS, 64-bit version  Windows 10 or 11 </p> <p>HDMI display monitor + HDMI cable </p> <p>Used to display demo programs or applications provided by HMI SDK.  * Connect to micro HDMI port of EVK </p> <p>If you need a touch panel function, you need a panel that supports USB connection.  The HMI SDK supports the display of resolutions supported by the Extended Display Identification Data (EDID) information obtained from this HDMI display monitor.</p> <p>USB mouse </p> <p>Used to operate demo programs and applications provided by HMI SDK.  * USB HID Compliant</p> <p>USB hub </p> <p>Used when multiple USB devices are required for the demo program or applications provided by HMI SDK.</p> <p>USB keyboard </p> <p>Used to operate demo programs and applications provided by HMI SDK.  * USB HID Compliant</p> <p>USB touch screen </p> <p>Used to operate demo programs and applications provided by HMI SDK.  * USB HID Compliant</p> <p>Audio speaker </p> <p>Used to evaluate the audio output demo programs or applications provided by HMI SDK.  * 3.5mm mini plug connector required</p> <p>micro SD card </p> <p>Linux and demo images provided by the HMI SDK are written and used as a Linux boot device.  Type: SDHC  Speed class: UHI-Class 10 * Capacity: Minimum 4GB, recommended 8GB</p> <p>Linux on the RZ/G2LC EVK is booted from a micro SD card by eSD boot. </p> <p>Equipment</p> <p>Purpose</p> <p>Remarks</p> <p>RZ/G2UL Module Board (SMARC2.1) + Common Carrier Board  (P/N: RTK9743U11S01000BE) </p> <p>It is used to evaluate not only Linux but also demo programs or applications that run on Linux in the Linux operating environment provided by HMI SDK.  4GB or more ROM (SPI or eMMC or SD)  1GB or more RAM (DDR4/DDR3L 16bit x 1.6/1.3Gbps)</p> <p>Included with RZ/G2UL Evaluation Board Kit (EVK) </p> <p>Parallel to HDMI conversion board </p> <p>It is used to convert FFC/FPC connector to micro HDMI connector. </p> <p>Included with RZ/G2UL Evaluation Board Kit (EVK) </p> <p>USB serial cable </p> <p>It is used to connect the PC and the EVK and get the console output of Linux running on the EVK.  * Connect to micro USB type-B (2.0) port of EVK</p> <p>Included with RZ/G2UL Evaluation Board Kit (EVK) </p> <p>USB Power Delivery (PD) AC adapter + USB C PD cable for power supply </p> <p>Used for power supply  * Connect to USB type-C port of EVK</p> <p>PC </p> <p>It can be used to operate the demo environment from a terminal on a PC, rebuild HMI SDK Linux, or use it as a development device for applications.  At least 100GB or more free space of HDD/SDD  8GB or more RAM * 4-core or more CPU</p> <p>The OS of the PC is as follows. However, Windows PCs are for debugging using a serial connection and cannot be used for development such as building software.  Ubuntu 22.04 LTS, 64-bit version  Windows 10 or 11 </p> <p>HDMI display monitor + HDMI cable </p> <p>Used to display demo programs or applications provided by HMI SDK.  * Connect to micro HDMI port of EVK </p> <p>If you need a touch panel function, you need a panel that supports USB connection.  The HMI SDK supports the display of resolutions supported by the Extended Display Identification Data (EDID) information obtained from this HDMI display monitor.</p> <p>USB mouse </p> <p>Used to operate demo programs and applications provided by HMI SDK.  * USB HID Compliant</p> <p>USB hub </p> <p>Used when multiple USB devices are required for the demo program or applications provided by HMI SDK.</p> <p>USB keyboard </p> <p>Used to operate demo programs and applications provided by HMI SDK.  * USB HID Compliant</p> <p>USB touch screen </p> <p>Used to operate demo programs and applications provided by HMI SDK.  * USB HID Compliant</p> <p>micro SD card </p> <p>Linux and demo images provided by the HMI SDK are written and used as a Linux boot device.  Type: SDHC  Speed class: UHI-Class 10 * Capacity: Minimum 4GB, recommended 8GB</p> <p>Linux on the RZ/G2UL EVK is booted from a micro SD card by eSD boot. </p>"},{"location":"getting_started/#2-necessary-software","title":"2. Necessary Software","text":"<p>Please install following software on Linux PC.</p> <ul> <li>git</li> </ul> <p>For information about installation and configuration of the tool, please refer to the first two instructions at Step 2: Build HMI SDK source code in How To Build HMI SDK.</p>"},{"location":"getting_started/#step-3-obtain-rzg-hmi-sdk","title":"Step 3: Obtain RZ/G HMI SDK","text":"<p>Please download from Renesas.com website.</p> RZ/G2LRZ/G2LCRZ/G2UL <p> Get HMI SDK for RZ/G2L EVKeSD boot image and toolchain installer package</p> <p> Get HMI SDK for RZ/G2LC EVKeSD boot image and toolchain installer package</p> <p> Get HMI SDK for RZ/G2UL EVKeSD boot image and toolchain installer package</p> <p>Once downloaded, please check the Release Note included inside package.</p>"},{"location":"getting_started/#step-4-prepare-hmi-sdk-sd-card-image-for-demo","title":"Step 4: Prepare HMI SDK SD card image for demo","text":"<p>Prebuilt binary prepared as <code>wic</code> image</p> RZ/G2LRZ/G2LCRZ/G2UL <p><code>wic</code> image is available inside <code>image-file_rzg2l_hmi-sdk_v2.3.1.0.zip</code>.</p> <p><code>wic</code> image is available inside <code>image-file_rzg2lc_hmi-sdk_v2.3.1.0.zip</code>.</p> <p><code>wic</code> image is available inside <code>image-file_rzg2ul_hmi-sdk_v2.3.1.0.zip</code>.</p>"},{"location":"getting_started/#1-in-case-of-windows-pc","title":"1. In case of Windows PC","text":"<ol> <li>Download or copy the release package into your PC</li> <li>Unzip the release package and extract an image file</li> <li> <p>Write the image file to your micro SD card by using one of the following tool</p> <ul> <li>Win32 Disk Imager</li> <li>balenaEtcher</li> </ul> RZ/G2LRZ/G2LCRZ/G2UL <p>Image file is:</p> <ul> <li><code>core-image-weston-smarc-rzg2l.wic.gz</code></li> </ul> <p>Image file is:</p> <ul> <li><code>core-image-weston-smarc-rzg2lc.wic.gz</code></li> </ul> <p>Image file is:</p> <ul> <li><code>core-image-bsp-smarc-rzg2ul.wic.gz</code></li> </ul> <p>Caution</p> <p>Even if you see a message such as <code>you need to format the disk</code> before/after writing the image, do not format the SD card.</p> </li> </ol>"},{"location":"getting_started/#2-in-case-of-linux-pc-ubuntu","title":"2. In case of Linux PC (Ubuntu)","text":"<ol> <li>Download or copy the release package into your PC</li> <li>Unzip the release package and extract an image file</li> <li> <p>Insert the micro SD Card into your Linux PC and find the device name of the SD card</p> <p>Use <code>lsblk</code> command to check the device name as follows.</p> <ul> <li> <p>Before inserting the SD card</p> <p></p><pre><code>lsblk\n</code></pre> <pre><code>NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\n\t(snip)\nnvme0n1     259:0    0 465.8G  0 disk\n\u251c\u2500nvme0n1p1 259:1    0   512M  0 part /boot/efi\n\u2514\u2500nvme0n1p2 259:2    0 465.3G  0 part /\n</code></pre> </li> <li> <p>After inserting the SD card</p> <p></p><pre><code>lsblk\n</code></pre> <pre><code>NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\n\t(snip)\nnvme0n1     259:0    0 465.8G  0 disk\n\u251c\u2500nvme0n1p1 259:1    0   512M  0 part /boot/efi\n\u2514\u2500nvme0n1p2 259:2    0 465.3G  0 part /\nsda           8:0    1  14.5G  0 disk\n\u251c\u2500sda1        8:1    1   500M  0 part /media/user/boot\n\u2514\u2500sda2        8:2    1   3.4G  0 part /media/user/rootfs\n</code></pre> </li> </ul> <p>Note</p> <p>The device name is assigned to the SD card by Linux on your Host PC. It may be named <code>/dev/sd*</code> (<code>*</code> is a letter representing the physical drive). It is <code>/dev/sda</code> in this sample.</p> </li> <li> <p>Unmount the SD card if it is mounted</p> <p>Use <code>umount</code> command with mount points that are displayed when you executed <code>lsblk</code> command. For example:</p> <p></p><pre><code>umount /media/user/boot\numount /media/user/rootfs\n</code></pre> </li> <li> <p>Write the image to the SD card</p> <p>Use <code>bmaptool</code> command with device name of SD card is displayed when you executed <code>lsblk</code> command. For example:</p> <p></p><pre><code>sudo bmaptool copy &lt;wic image&gt;.wic.gz /dev/sda\n</code></pre> RZ/G2LRZ/G2LCRZ/G2UL <p>Image file is:</p> <ul> <li><code>core-image-weston-smarc-rzg2l.wic.gz</code></li> </ul> <p>Note</p> <p>Additionally, the files below are also required:</p> <ul> <li><code>core-image-weston-smarc-rzg2l.wic.bmap</code></li> </ul> <p>Image file is:</p> <ul> <li><code>core-image-weston-smarc-rzg2lc.wic.gz</code></li> </ul> <p>Note</p> <p>Additionally, the files below are also required:</p> <ul> <li><code>core-image-weston-smarc-rzg2lc.wic.bmap</code></li> </ul> <p>Image file is:</p> <ul> <li><code>core-image-bsp-smarc-rzg2ul.wic.gz</code></li> </ul> <p>Note</p> <p>Additionally, the files below are also required:</p> <ul> <li><code>core-image-bsp-smarc-rzg2ul.wic.bmap</code></li> </ul> </li> </ol>"},{"location":"getting_started/#step-5-run-hmi-sdk-demo","title":"Step 5: Run HMI SDK demo","text":""},{"location":"getting_started/#1-setup-evks-peripheral","title":"1. Setup EVK's peripheral","text":"<p>Please setup following below diagram.</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p> <p></p> <p></p>"},{"location":"getting_started/#2-setup-evks-dip-switch","title":"2. Setup EVK's DIP switch","text":"RZ/G2LRZ/G2LCRZ/G2UL <p>Set up DIP switch SW1 and SW11 as follows.</p> <ul> <li> <p>SW1</p> <p></p> SW1-1 SW1-2 ON ON </li> <li> <p>SW11</p> <p></p> SW11-1 SW11-2 SW11-3 SW11-4 ON ON OFF ON </li> </ul> <p>Set up DIP switch SW1 and SW11 as follows.</p> <ul> <li> <p>SW1</p> <p></p> SW1-1 SW1-2 SW1-3 SW1-4 SW1-5 SW1-6 ON ON ON* OFF* ON* Not used <p>* Set the switches to suit your purpose.</p> </li> <li> <p>SW11</p> <p></p> SW11-1 SW11-2 SW11-3 SW11-4 ON ON OFF ON </li> </ul> <p>Set up DIP switch SW1 and SW11 as follows.</p> <ul> <li> <p>SW1</p> <p></p> SW1-1 SW1-2 SW1-3 ON ON ON* <p>* Set the switches to suit your purpose.</p> </li> <li> <p>SW11</p> <p></p> SW11-1 SW11-2 SW11-3 SW11-4 ON ON OFF ON </li> </ul>"},{"location":"getting_started/#3-turn-on-evk-and-run-demo","title":"3. Turn on EVK and run demo","text":"<ol> <li>Insert the bootable SD card created at Step 4 into the microSD card slot on SMARC module board as illustrated in the figure at \"1. Setup EVK's peripheral\".</li> <li>Connect a USB cable to CN6 for power supply.</li> <li> <p>Press and hold power button (SW9) for 1 second to turn on the EVK.</p> <p>Note</p> <p>Press and hold the button for 2 seconds when you turn off the EVK.</p> </li> </ol>"},{"location":"getting_started/#step-6-build-sample-application","title":"Step 6: Build sample application","text":"<p>This step explains how to build HMI SDK sample application.  To see the overview about HMI Applications, please refer to HMI Applications.</p> <p>Note</p> <p>This step requires a Linux PC (Ubuntu).</p> <p>The prebuilt binary of executable files are also provided, and you can run them without building.</p> <ol> <li> <p>Install cross-toolchain to you Linux PC (Ubuntu)</p> <p>Note</p> <p>This step is optional, as prebuilt binaries was prepared.</p> RZ/G2LRZ/G2LCRZ/G2UL <p>The toolchain installer is available inside toolchain-installer_rzg2l_hmi-sdk_v2.3.1.0.zip. Unzip the package, and extract the installer. Then, install the toolchain as follows:</p> <p></p><pre><code>sudo sh poky-glibc-x86_64-core-image-weston-aarch64-smarc-rzg2l-toolchain-3.1.33.sh\n</code></pre> <p>The toolchain installer is available inside toolchain-installer_rzg2lc_hmi-sdk_v2.3.1.0.zip. Unzip the package, and extract the installer. Then, install the toolchain as follows:</p> <p></p><pre><code>sudo sh poky-glibc-x86_64-core-image-weston-aarch64-smarc-rzg2lc-toolchain-3.1.33.sh\n</code></pre> <p>The toolchain installer is available inside toolchain-installer_rzg2ul_hmi-sdk_v2.3.1.0.zip. Unzip the package, and extract the installer. Then, install the toolchain as follows:</p> <p></p><pre><code>sudo sh poky-glibc-x86_64-core-image-bsp-aarch64-smarc-rzg2ul-toolchain-3.1.33.sh\n</code></pre> <p>Note</p> <p>Please set target directory (default: <code>/opt/poky/3.1.33</code>).</p> </li> <li> <p>Enable cross compiler</p> <p>Note</p> <p>This step is optional, as prebuilt binaries was prepared.</p> <p></p><pre><code>source /opt/poky/3.1.33/environment-setup-aarch64-poky-linux\n</code></pre> <p>Note</p> <p>Please make sure where cross compiler is installed (default: <code>/opt/poky/3.1.33</code>).</p> </li> <li> <p>Clone sample application source code</p> <p></p><pre><code>git clone https://github.com/renesas-rz/rzg_hmi_sdk\n</code></pre> </li> <li> <p>Go to source code working directory</p> <p></p><pre><code>cd rzg_hmi_sdk/sample_app/&lt;sample-application-directory&gt;\n</code></pre> <p>Note</p> <p>Existing <code>&lt;sample-application-directory&gt;</code>(s) are listed on below table.</p> <code>&lt;sample-application-directory&gt;</code> Description <code>lvgl/lvgl_sample_img_disp</code> LVGL Sample Program for Image Display <code>lvgl/lvgl_sample_audio_playback</code> LVGL Sample Program for Audio Playback <code>lvgl/lvgl_sample_video_playback</code> LVGL Sample Program for Video Playback </li> <li> <p>Build sample application</p> <p>Note</p> <p>This step is optional, as prebuilt binaries was prepared.</p> <p></p><pre><code>make\n</code></pre> </li> <li> <p>Executable file of sample application</p> <p>Each executable file of sample application built as <code>rzg_hmi_sdk/sample_app/&lt;sample-application-directory&gt;/&lt;sample-application-binary&gt;</code>.</p> <p>Note</p> <p>Executable file name (<code>&lt;sample-application-binary&gt;</code>) are same with the directory name. For example in case <code>lvgl_sample_img_disp</code>, path to executable file is:</p> <p></p><pre><code>&lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_img_disp/lvgl_sample_img_disp\n</code></pre> <p>In addition, prebuilt executable binaries are stored in 'bin' directory. For example in case <code>lvgl_sample_img_disp</code>, path to the prebuilt executable file is:</p> <p></p><pre><code>&lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_img_disp/bin/lvgl_sample_img_disp\n</code></pre> </li> </ol>"},{"location":"getting_started/#step-7-deploy-sample-application","title":"Step 7: Deploy sample application","text":"<p>Note</p> <p>This step requires a Linux PC (Ubuntu).</p>"},{"location":"getting_started/#1-over-ethernet-using-scp","title":"1. Over ethernet (using <code>SCP</code>)","text":"<ol> <li> <p>Boot and connect your EVK into your local network</p> <p>Connect an ethernet cable to RJ45 port for networking.</p> RZ/G2LRZ/G2LCRZ/G2UL <p>RJ45 ports are CN9 (Ethernet 0) and CN8 (Ethernet 1).</p> <p>Note</p> <p>Just connect 1 ethernet cable to CN9 or CN8.</p> <p>RJ45 ports is CN9 (Ethernet 0).</p> <p>Note</p> <p>Just connect a ethernet cable to CN9.</p> <p>RJ45 ports are CN9 (Ethernet 0) and CN8 (Ethernet 1).</p> <p>Note</p> <p>Just connect 1 ethernet cable to CN9 or CN8.</p> <p>Note</p> <p>Your EVK will run the demo program automatically.</p> <p>Please exit the demo by pressing the keyboard keys Ctrl+C, before proceeding to the next step.</p> </li> <li> <p>Check your EVK's IP</p> <p>Open terminal of your EVK, and check using <code>ip</code> command as below.</p> <p></p><pre><code>ip a\n</code></pre> <p>Note</p> <p>For example, when RZ/G2L EVK's CN8 ethernet port connected to local network.</p> <pre><code>root@smarc-rzg2l:~# ip a | grep eth\n5: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,DYNAMIC,UP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000\n    link/ether f2:d6:18:24:f0:6b brd ff:ff:ff:ff:ff:ff\n6: eth1: &lt;BROADCAST,MULTICAST,DYNAMIC,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000\n    link/ether 72:26:f0:8b:64:59 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.0.32/24 brd 192.168.0.255 scope global dynamic eth1\n</code></pre> <p>EVK's IP is <code>192.168.0.32</code> (at <code>eth1</code>).</p> </li> <li> <p>Copy executable into your EVK storage (SD card)</p> <p>Send executable file from your Linux PC (Ubuntu) using <code>scp</code> command as below.</p> <p></p><pre><code>scp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/&lt;sample-application-directory&gt;/&lt;sample-application-binary&gt; root@&lt;your-EVK-IP&gt;:/home/root/\n</code></pre> <p>Note</p> <p>We recommend you to copy to <code>/home/root</code> directory.</p> <p>Don't forget to replace <code>&lt;your-EVK-IP&gt;</code> with your EVK's IP.</p> </li> <li> <p>Copy resources required by sample application</p> <code>lvgl_sample_img_disp</code><code>lvgl_sample_audio_playback</code><code>lvgl_sample_video_playback</code> <p></p><pre><code>scp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_img_disp/sample/* root@&lt;your-EVK-IP&gt;:/usr/share/images/\n</code></pre> <p>Caution</p> <p>Make sure you are copying to <code>/usr/share/images/</code> directory of EVK.</p> <p></p><pre><code>scp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_audio_playback/sample/* root@&lt;your-EVK-IP&gt;:/usr/share/sounds/sample/\n</code></pre> <p>Caution</p> <p>Make sure you are copying to <code>/usr/share/sounds/sample/</code> directory of EVK.</p> <p></p><pre><code>scp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_video_playback/sample/* root@&lt;your-EVK-IP&gt;:/usr/share/movies/\n</code></pre> <p>Caution</p> <p>Make sure you are copying to <code>/usr/share/movies/</code> directory of EVK.</p> </li> </ol>"},{"location":"getting_started/#2-directly-write-into-hmi-sdks-sd-card","title":"2. Directly write into HMI SDK's SD card","text":"<ol> <li>Turn off your EVK (if its on)</li> <li>Insert and mount your SD card into PC</li> <li> <p>Copy executable into your SD card</p> <p>For example, in case mounted on <code>/media/user/rootfs</code>.</p> <p></p><pre><code>cp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/&lt;sample-application-directory&gt;/&lt;sample-application-binary&gt; /media/user/rootfs/home/root/\n</code></pre> <p>Note</p> <p>We recommend you to copy to <code>/home/root</code> directory.</p> <p>If you not sure where is your SD card mounted, please check it using <code>lsblk</code> command (see Step 4.2.3).</p> </li> <li> <p>Copy resources required by sample application</p> <p>For example, in case mounted on <code>/media/user/rootfs</code>.</p> <code>lvgl_sample_img_disp</code><code>lvgl_sample_audio_playback</code><code>lvgl_sample_video_playback</code> <p></p><pre><code>cp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_img_disp/sample/* /media/user/rootfs/usr/share/images/\n</code></pre> <p>Caution</p> <p>Make sure you are copying to <code>/usr/share/images/</code> directory on SD card.</p> <p></p><pre><code>cp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_audio_playback/sample/* /media/user/rootfs/usr/share/sounds/sample/\n</code></pre> <p>Caution</p> <p>Make sure you are copying to <code>/usr/share/sounds/sample/</code> directory on SD card.</p> <p></p><pre><code>cp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_video_playback/sample/* /media/user/rootfs/usr/share/movies/\n</code></pre> <p>Caution</p> <p>Make sure you are copying to <code>/usr/share/movies/</code> directory on SD card.</p> </li> </ol>"},{"location":"getting_started/#step-8-run-sample-application","title":"Step 8: Run sample application","text":"<ol> <li> <p>Boot your EVK (if not yet)</p> <p>Note</p> <p>Your EVK will run the demo program automatically.</p> <p>Please exit the demo by pressing the keyboard keys Ctrl+C, before proceeding to the next step.</p> </li> <li> <p>Go to <code>/home/root</code> directory</p> <p>Open terminal of your EVK, and go to <code>/home/root</code> using <code>cd</code> command as below.</p> <p></p><pre><code>cd /home/root\n</code></pre> </li> <li> <p>Set sample application binary executable</p> <p></p><pre><code>chmod +x &lt;sample-application-binary&gt;\n</code></pre> </li> <li> <p>Execute sample application binary</p> <p></p><pre><code>./&lt;sample-application-binary&gt;\n</code></pre> </li> </ol>"},{"location":"history/","title":"Version","text":""},{"location":"history/#version","title":"Version","text":""},{"location":"history/#rzg-hmi-sdk-v2310","title":"RZ/G HMI SDK v2.3.1.0","text":"<p>2025/08/07</p> <p>RZ/G HMI SDK version 2.3.1.0 is available.</p> <ul> <li>Update VLP/G from v3.0.6 update3 to v3.0.7.</li> <li>Update RZ MPU HTML5 (Chromium) Package for VLP from v1.0.0 to v1.0.1<ul> <li>Add support for hardware video decoding on Chromium (RZ/G2L only).</li> </ul> </li> <li>Add a video player to home panel demo running on Chromium (RZ/G2L only).</li> <li>Add a sample application program \u2019LVGL home panel demo\u2019.</li> </ul>"},{"location":"history/#rzg-hmi-sdk-v2300","title":"RZ/G HMI SDK v2.3.0.0","text":"<p>2024/12/27</p> <p>RZ/G HMI SDK version 2.3.0.0 is available.</p> <ul> <li>Add Chromium (except for RZ/G2UL)</li> <li>Update VLP/G from v3.0.6 update2 to v3.0.6 update3.</li> <li>Add support for RZ/G2LC Evaluation Board Kit and RZ/G2UL Evaluation Board Kit.</li> <li>Add sample application programs, home panel demo (RZ/G2L only) and demo launcher.</li> </ul>"},{"location":"history/#rzg-hmi-sdk-v100","title":"RZ/G HMI SDK v1.00","text":"<p>2024/07/31</p> <p>RZ/G HMI SDK v1.00 is available.</p> <p>Back to Home &gt;</p>"},{"location":"hmi_frameworks/_components/__front_matter/","title":"front matter","text":""},{"location":"hmi_frameworks/_components/__front_matter/#hmi-frameworks","title":"HMI Frameworks","text":"<p>The HMI SDK supports the following GUI frameworks and libraries that are appropriate for HMI. In addition, the HMI SDK provides HMI sample applications implemented by using the GUI frameworks and libraries. For more information about the applications, see Overview.</p>"},{"location":"hmi_frameworks/_components/__front_matter/#lvgl-light-and-versatile-graphics-library","title":"LVGL (Light and Versatile Graphics Library)","text":"<p>LVGL is the most popular free and open-source embedded graphics library to create beautiful UIs for any MCU, MPU and display type. It is a lightweight graphics library, and it works without GPU. In addition, a lot of sample applications are available. They would be helpful to users.</p>"},{"location":"hmi_frameworks/_components/__front_matter/#chromium","title":"Chromium","text":"<p>Chromium is the most popular browser in recent years, and it is increasingly being adopted for embedded products. You can implement HTML5-based solutions using Chromium. It uses GPU for its rendering.</p> <p>A browser-based GUI on Chromium (HTML5 solutions) offers several advantages:</p> <ul> <li>Feature-rich user interface</li> <li>Cross-platform compatibility</li> <li>Lower development costs</li> </ul>"},{"location":"how_to_build_hmi_sdk/","title":"How To Build HMI SDK","text":""},{"location":"how_to_build_hmi_sdk/#how-to-build-hmi-sdk","title":"How To Build HMI SDK","text":""},{"location":"how_to_build_hmi_sdk/#introduction","title":"Introduction","text":"<p>HMI SDK is a quick and easy HMI Application development environment.</p> <p>To modify Linux component, you need to build HMI SDK from source code. HMI SDK source code will generate same Linux environment as HMI SDK.</p> <p>This page explains how to build HMI SDK source code. After you have completed this page, you would be able to change the source code and customize Linux environment (i.e., memory map, additional OSS etc...).</p> <p>Notice</p> <p>Several updated OSS components, aimed at addressing vulnerabilities and improving drivers, have been published on Renesas' GitHub. Please refer to Update Linux Package in HMI SDK for instructions on how to replace them.</p> <p>Requirement</p> <ol> <li>Users have launched Evaluation Board Kit according to Getting Started,     which means they can run HMI Application on the board.</li> <li> <p>To build Yocto Linux, the below equipment should be prepared.</p> <p>Equipment</p> <p>Details</p> <p>Linux PC </p> <p>Approximately the following free space is necessary. - 150 GB for RZ/G2L EVK - 150 GB for RZ/G2LC EVK - 85 GB for RZ/G2UL EVK</p> <p>OS </p> <p>Ubuntu 22.04 LTS  64bit OS must be used.</p> </li> </ol>"},{"location":"how_to_build_hmi_sdk/#step-1-obtain-hmi-sdk-yocto-recipe","title":"Step 1: Obtain HMI SDK Yocto recipe","text":"<p>Download HMI SDK Yocto recipe and pre-built binary image package from below link.</p> RZ/G2LRZ/G2LCRZ/G2UL <p> Get HMI SDK for RZ/G2L EVKYocto recipe and pre-built binary image package</p> <p> Get HMI SDK for RZ/G2LC EVKYocto recipe and pre-built binary image package</p> <p> Get HMI SDK for RZ/G2UL EVKYocto recipe and pre-built binary image package</p> <p>In the build process, source code of modules in the HMI SDK will be downloaded via network connection, but you can use the same source code used for creating the HMI SDK binaries. Download HMI SDK source code from below link.</p> <p> Get HMI SDKSource code package</p> <p>Note</p> <p>The HMI SDK source code package file is quite large. It will take a long time to download it.</p>"},{"location":"how_to_build_hmi_sdk/#step-2-build-hmi-sdk-source-code","title":"Step 2: Build HMI SDK source code","text":"<p>This step explains how to build Linux environment with HMI SDK source code.</p> <p>Note</p> <p>In the following instructions, text in angle brackets should be replaced with a character string that depends on your environment.</p> <p>The brackets <code>&lt;</code> and <code>&gt;</code> are unnecessary in the text.</p> <ol> <li> <p>Install the required packages</p> <p>Install some packages into your Linux PC, which are necessary in the following steps.</p> <p></p><pre><code>sudo apt-get update\nsudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping libsdl1.2-dev xterm p7zip-full libyaml-dev libssl-dev bmap-tools\n</code></pre> </li> <li> <p>Set up your <code>git</code> environment</p> <p>Set up your <code>git</code> environment if you have never done it.</p> <p></p><pre><code>git config --global user.email \"&lt;Your email address&gt;\"\ngit config --global user.name \"&lt;Your user name&gt;\"\n</code></pre> <p>Note</p> <p>For more information, refer to Yocto Project Quick Build.</p> </li> <li> <p>Set environment variables</p> <p>Set the following environment variables.</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p><pre><code>export WORK=&lt;A directory path for building&gt;\nexport PLATFORM=rzg2l\nexport BOARD=smarc-rzg2l\nexport SDK_PKG_DIR=&lt;A directory path for HMI SDK source code packages&gt;\n</code></pre> <p></p><pre><code>export WORK=&lt;A directory path for building&gt;\nexport PLATFORM=rzg2l\nexport BOARD=smarc-rzg2lc\nexport SDK_PKG_DIR=&lt;A directory path for HMI SDK source code packages&gt;\n</code></pre> <p></p><pre><code>export WORK=&lt;A directory path for building&gt;\nexport PLATFORM=rzg2l\nexport BOARD=smarc-rzg2ul\nexport SDK_PKG_DIR=&lt;A directory path for HMI SDK source code packages&gt;\n</code></pre> <p>Note</p> <p>The directory set to <code>SDK_PKG_DIR</code> shall include the HMI SDK packages such as <code>RTK0EF0195F*SJ_${PLATFORM}_yocto-and-pre-built-image.zip</code> and <code>RTK0EF0195F*SJ_linux-src.zip</code>.</p> </li> <li> <p>Extract Yocto recipe package</p> <p>Decompress the Yocto recipe and pre-built binary image package, create a working directory, and extract Yocto recipe package.</p> <p></p><pre><code>cd ${SDK_PKG_DIR}\nunzip RTK0EF0195F*SJ_${PLATFORM}_yocto-and-pre-built-image.zip\n</code></pre> <p></p><pre><code>mkdir -p ${WORK}\ncd ${WORK}\ntar xf ${SDK_PKG_DIR}/RTK0EF0195F*SJ_${PLATFORM}_yocto-and-pre-built-image/yocto_recipe_rzg2_hmi-sdk_v*.tar.gz --strip-components 1\n</code></pre> </li> <li> <p>Initialize build environment</p> <p>Run an environment setup script as follows.</p> <p></p><pre><code>cd ${WORK}\nTEMPLATECONF=${PWD}/meta-renesas/meta-${PLATFORM}/docs/template/conf/ source poky/oe-init-build-env build\n</code></pre> </li> <li> <p>Add layers</p> <p>Add necessary Yocto <code>meta-layers</code> layer as follows.</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p><pre><code>cd ${WORK}/build\nbitbake-layers add-layer ../meta-rz-features/meta-rz-graphics\nbitbake-layers add-layer ../meta-rz-features/meta-rz-codecs\nbitbake-layers add-layer ../meta-clang\nbitbake-layers add-layer ../meta-browser/meta-chromium\nbitbake-layers add-layer ../meta-openembedded/meta-networking\nbitbake-layers add-layer ../meta-browser-hwdecode\nbitbake-layers add-layer ../meta-rz-demos\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nbitbake-layers add-layer ../meta-rz-features/meta-rz-graphics\nbitbake-layers add-layer ../meta-clang\nbitbake-layers add-layer ../meta-browser/meta-chromium\nbitbake-layers add-layer ../meta-openembedded/meta-networking\nbitbake-layers add-layer ../meta-browser-hwdecode\nbitbake-layers add-layer ../meta-rz-demos\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nbitbake-layers add-layer ../meta-rz-demos\n</code></pre> </li> <li> <p>Set up environment for offline build</p> <p>This step is configuration for offline building.</p> <p>If you would like to get source code via network when you build the HMI SDK, skip this step.</p> <p>Change the environment variable <code>BB_NO_NETWORK</code> in <code>local.conf</code> from <code>0</code>  to <code>1</code> using <code>sed</code> command.</p> <p></p><pre><code>cd ${WORK}/build\nsed -i \"s|\\(BB_NO_NETWORK =.*\\)\\\"0\\\"|\\1\\\"1\\\"|\" \"conf/local.conf\"\n</code></pre> <p>Decompress source code package and set it into the build environment.</p> <p></p><pre><code>cd ${SDK_PKG_DIR}\nunzip RTK0EF0195F*SJ_linux-src.zip\ncd ${SDK_PKG_DIR}/RTK0EF0195F*SJ_linux-src/\n7z x oss-souce-code-pkg_rzg2_hmi-sdk_v*.7z\nmv downloads/ ${WORK}/build/\n</code></pre> </li> <li> <p>Modify configurations for build environment</p> <p>Add <code>IMAGE_INSTALL_append</code> and other settings to <code>local.conf</code> as follows.</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p><pre><code>cd ${WORK}/build\nsed -i '$aIMAGE_INSTALL_append = \\\" packagegroup-lvgl-demo packagegroup-benchmark-tools packagegroup-chromium-demo packagegroup-rzg-hmi-sdk-demo \\\"' \"conf/local.conf\"\nsed -i '$aWHITELIST_GPL-3.0 += \\\" glmark2 \\\"' \"conf/local.conf\"\nsed -i '$aPREFERRED_VERSION_nodejs-native = \\\"14.%\\\"' \"conf/local.conf\"\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nsed -i '$aIMAGE_INSTALL_append = \\\" packagegroup-lvgl-demo packagegroup-benchmark-tools packagegroup-chromium-demo packagegroup-rzg-hmi-sdk-demo \\\"' \"conf/local.conf\"\nsed -i '$aWHITELIST_GPL-3.0 += \\\" glmark2 \\\"' \"conf/local.conf\"\nsed -i '$aPREFERRED_VERSION_nodejs-native = \\\"14.%\\\"' \"conf/local.conf\"\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nsed -i '$aIMAGE_INSTALL_append = \\\" packagegroup-lvgl-demo packagegroup-benchmark-tools packagegroup-rzg-hmi-sdk-demo \\\"' \"conf/local.conf\"\n</code></pre> </li> <li> <p>Build images</p> <p>Run <code>bitbake</code> command to build images.</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston\n</code></pre> <p>After the above build process, change the setting of EMMC from '1' to '0'. </p><pre><code>cd $WORK/build/tmp/work-shared/${BOARD}/kernel-source\nvi arch/arm64/boot/dts/renesas/rzg2l-smarc-som.dtsi\n    (change EMMC setting)\n        before) #define EMMC\t1\n        after)  #define EMMC\t0\n</code></pre> <p>After the change above, you need to have additional build process as follows: </p><pre><code>cd $WORK/build\nMACHINE=${BOARD} bitbake linux-renesas -C compile\nMACHINE=${BOARD} bitbake core-image-weston\n</code></pre> <p>Note</p> <p>If you need to create an SDK toolchain, run <code>bitbake</code> command as follows.</p> <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston -c populate_sdk\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston\n</code></pre> <p>After the above build process, change the setting of SW_SD0_DEV_SEL from '1' to '0'. </p><pre><code>cd $WORK/build/tmp/work-shared/${BOARD}/kernel-source\nvi arch/arm64/boot/dts/renesas/r9a07g044c2-smarc.dts\n    (change SW_SD0_DEV_SEL setting)\n        before) #define SW_SD0_DEV_SEL 1\n        after)  #define SW_SD0_DEV_SEL 0\n</code></pre> <p>After the change above, you need to have additional build process as follows: </p><pre><code>cd $WORK/build\nMACHINE=${BOARD} bitbake linux-renesas -C compile\nMACHINE=${BOARD} bitbake core-image-weston\n</code></pre> <p>Note</p> <p>If you need to create an SDK toolchain, run <code>bitbake</code> command as follows.</p> <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston -c populate_sdk\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-bsp\n</code></pre> <p>Note</p> <p>If you need to create an SDK toolchain, run <code>bitbake</code> command as follows.</p> <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-bsp -c populate_sdk\n</code></pre> <p>Note</p> <p>After building images or SDK toolchain, you can find them in the following directories respectively.</p> <ul> <li>Images: <code>${WORK}/build/tmp/deploy/images/${BOARD}/</code></li> <li>SDK toolchain: <code>${WORK}/build/tmp/deploy/sdk/</code></li> </ul> </li> </ol>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#overview","title":"Overview","text":"<p>RZ/G HMI Software Development Kit (HMI SDK) is an HMI application development environment for Evaluation Board Kit of RZ/G series.</p> <p>Since it contains Yocto Linux with bootloader, Linux Kernel, Cross Compiler, multimedia and graphics package, users can develop HMI Applications\u00a0easily\u00a0and\u00a0quickly\u00a0with HMI SDK.</p> <p>HMI SDK is specifically made for the supported Evaluation Board Kit with fixed Linux components. If you need to customize the Linux environment\u2014such as modifying the memory map or developing support for your own board\u2014you will need to build Yocto Linux from source.</p> <p>For detailed instructions, please refer to How to build HMI SDK.</p> <p>How To Build HMI SDK</p>"},{"location":"overview/#supported-boards","title":"Supported Boards","text":"<ul> <li>RZ/G2L  Evaluation Board Kit (RTK9744L23S01000BE)</li> <li>RZ/G2LC Evaluation Board Kit (RTK9744C22S01000BE)</li> <li>RZ/G2UL Evaluation Board Kit (RTK9743U11S01000BE)</li> </ul>"},{"location":"overview/#sdk-components","title":"SDK Components","text":"<p>HMI SDK provides the following packages:</p> <ul> <li> <p>eSD boot image and toolchain installer package</p> <p>This package is the heart of HMI SDK. You can create a bootable microSD card, set up Linux environment on the EVK, and build sample applications.</p> </li> <li> <p>Yocto recipe and pre-built binary image package</p> <p>This is an optional package. If you would like to build the HMI SDK from scratch, or you would like to try QSPI boot or eMMC boot (other than eSD boot mode), get this package.</p> </li> <li> <p>Source code package</p> <p>When you build the HMI SDK from scratch, you can use source code in this package for offline building.</p> </li> </ul> <p>Except for the source code package, the packages are available for each EVK.</p>"},{"location":"overview/#file-contents","title":"File Contents","text":"<p>The contents of the packages are as follows:</p> <p>Package</p> <p>File Name</p> <p>Details</p> <p>eSD boot image and toolchain installer package (RTK0EF0195F02310SJ_&lt;dev&gt;) </p> <p>image-file_&lt;dev&gt;_hmi-sdk_v2.3.1.0.zip</p> <p>Bootable SD card images in WIC format</p> <p>licenses_rzg2_hmi-sdk_v2.3.1.0.zip</p> <p>License files for open-source software used in HMI SDK</p> <p>r01an7976ej0100-rzg-hmi-sdk.pdf</p> <p>Release note that contains RZ/G HMI SDK release information</p> <p>README.txt</p> <p>README that contains information about the package</p> <p>toolchain-installer_&lt;dev&gt;_hmi-sdk_v2.3.1.0.zip</p> <p>Installer for pre-built cross-toolchain used for building sample applications</p> <p>Yocto recipe and pre-built binary image package (RTK0EF0195F02310SJ_&lt;dev&gt;_yocto-and-pre-built-image) </p> <p>licenses_rzg2_hmi-sdk_v2.3.1.0.zip</p> <p>License files for open-source software used in HMI SDK</p> <p>pre-built-binary_&lt;dev&gt;_hmi-sdk_v2.3.1.0.zip</p> <p>Pre-built binaries (boot loader, Linux kernel image and root filesystem, flash writer) for SPI boot mode (option)</p> <p>r01an7976ej0100-rzg-hmi-sdk.pdf</p> <p>Release note that contains RZ/G HMI SDK release information</p> <p>README.txt</p> <p>README that contains information about the package</p> <p>yocto_recipe_rzg2_hmi-sdk_v2.3.1.0.tar.gz</p> <p>Yocto meta layers used for building HMI SDK</p> <p>Source code package (RTK0EF0195F02310SJ_linux-src) </p> <p>licenses_rzg2_hmi-sdk_v2.3.1.0.zip</p> <p>License files for open-source software used in HMI SDK</p> <p>oss-souce-code-pkg_rzg2_hmi-sdk_v2.3.1.0.7z</p> <p>Source code package of open-source software used for building HMI SDK</p> <p>r01an7976ej0100-rzg-hmi-sdk.pdf</p> <p>Release note that contains RZ/G HMI SDK release information</p> <p>README.txt</p> <p>README that contains information about the package</p> <p>&lt;dev&gt; in the above table stands for a device name, such as rzg2l, rzg2lc, or rzg2ul.</p>"},{"location":"overview/#hmi-applications","title":"HMI Applications","text":"<p>HMI SDK provides HMI demos and sample applications.  These are available as both source code and prebuilt binaries, allowing you to run them on the board immediately and customize them as needed.</p> Sample Application Name Description Pre-installed in SD Card Image Target Device Source Code URL LVGL Sample Program for Image Display <code>lvgl_sample_img_disp</code> This program is implemented using LVGL, and it can display image files in bmp/jpg/png/gif format. No RZ/G2L, RZ/G2LC, RZ/G2UL Link to GitHub LVGL Sample Program for Audio Playback <code>lvgl_sample_audio_playback</code> This program is implemented using LVGL, and it can play audio files in mp3/aac/wav format. No RZ/G2L, RZ/G2LC Link to GitHub LVGL Sample Program for Video Playback <code>lvgl_sample_video_playback</code> This program is implemented using LVGL, and it can play a movie file in mp4 format. No RZ/G2L Link to GitHub LVGL RZ Linux Benchmark Demo <code>rz_benchmark_demo</code> RZ Linux Benchmark Demo is implemented using LVGL, and some benchmarks can be run on the demo. Yes RZ/G2L, RZ/G2LC, RZ/G2UL Link to GitHub Chromium Home Panel Demo Chromium Home Panel Demo is an HTML5 Single Page Web Application, and it is a demo for home panel.Please click the browser's refresh button before using the seek bar of the 'Video Player'. Yes RZ/G2L, RZ/G2LC Link to GitHub LVGL Home Panel Demo LVGL Home Panel Demo is implemented using LVGL, and it is a demo for home panel. Yes RZ/G2L, RZ/G2LC, RZ/G2UL Link to GitHub <p>The pre-installed applications can be run from a launcher program that starts automatically when the HMI SDK Linux launches. To run other applications, see Step 8 at Getting Started.</p>"},{"location":"overview/#specification","title":"Specification","text":"<p>RZ/G HMI SDK includes the following software packages:</p> <ul> <li>RZ/G Verified Linux Package Version 3.0.7</li> <li>RZ MPU Graphics Library V3.1.2.3 for RZ/G2L and RZ/G2LC</li> <li>RZ MPU Video Codec Library V3.1.3.0 for RZ/G2L</li> </ul> <p>Please refer to the table below for more information.</p>"},{"location":"overview/#features","title":"Features","text":"Components Version Detail Linux Kernel 5.10.229-cip54 SLTS(Super Long Term Support) Kernel Yocto 3.1.31 (dunfell) Distribution for embedded Linux gcc 8.3.0 (Arm GCC 8.3-2019.03) Compiler glibc 2.28 busybox 1.30.1 openssl 1.1.1n GStreamer1.0<sup>1</sup> 1.16.3 GStreamer UM for RZ/G2L wayland 1.18.0 weston 8.0.0 Python3 3.8.18 lvgl 8.3.11 lv-drivers 8.3.0 Firacode 6.2 Tomlc99 *<sup>2</sup> OpenCL OpenCL Overview OpenGLES OpenGL ES Overview OpenMAX IL 1.1 OpenMAX IL Overview <ol> <li> <p>For GStreamer Sample Applications please visit this repository. \u21a9</p> </li> <li> <p>Commit ID 5221b3d. \u21a9</p> </li> </ol>"},{"location":"overview/#related-documents","title":"Related Documents","text":"<p>For details on the functions and interface specifications of driver modules, please refer to the software user\u2019s manual.</p> <p> Get BSP User's Manual: SoftwareRZ/G2L Group, RZ/V2L Group, and RZ/Five</p> <p> Get GStreamer User's Manual: SoftwareRZ/G2L Group and RZ/V2L Group</p>"},{"location":"wiki/","title":"Wiki","text":""},{"location":"wiki/#wiki","title":"Wiki","text":"<p>This page contains information and tips related to the RZ/G HMI SDK.</p>"},{"location":"wiki/#common","title":"Common","text":"<ul> <li>Change display resolution</li> <li>Update firmware (bootloaders) on EVK</li> <li>Boot Linux from microSD card</li> <li>Debug application using GDB</li> <li>Update Linux Package in HMI SDK</li> </ul>"},{"location":"wiki/#lvgl","title":"LVGL","text":"<ul> <li>Develop LVGL GUI application using EEZ Studio</li> </ul>"},{"location":"wiki/#chromium","title":"Chromium","text":"<p>Coming Soon!! </p>"},{"location":"wiki/common_boot-linux-from-sd/","title":"Boot Linux from microSD card","text":""},{"location":"wiki/common_boot-linux-from-sd/#boot-linux-from-microsd-card","title":"Boot Linux from microSD card","text":"<p>This page describes how to boot Linux of the HMI SDK from a microSD card in QSPI boot mode.</p> <p>Please note that you need to update bootloaders in Flash ROM on the EVK to use the QSPI boot mode.  In the eSD boot mode, bootloaders stored in the microSD card are used, but bootloaders stored in the ROM are used when you use the QSPI boot mode.  For information about how to update bootloaders, see Update firmware (bootloaders) on EVK.</p>"},{"location":"wiki/common_boot-linux-from-sd/#1-create-a-bootable-microsd-card","title":"1. Create a bootable microSD card","text":"<p>Get a microSD card ready. For information about requirements for the microSD card, see 1. Necessary Equipment. And for information about how to create a bootable microSD card, see Step 4: Prepare HMI SDK SD card image for demo.</p>"},{"location":"wiki/common_boot-linux-from-sd/#2-set-boot-mode-to-qspi-boot-mode","title":"2. Set boot mode to QSPI boot mode","text":"<p>To use QSPI boot mode, set the SW11 as follows.</p> <p></p> SW11-1 SW11-2 SW11-3 SW11-4 OFF OFF OFF ON"},{"location":"wiki/common_boot-linux-from-sd/#3-set-bootable-microsd-card","title":"3. Set bootable microSD card","text":"<p>Insert the bootable microSD card into the card slot on RZ SMARC Carrier Board.</p> <p></p> <p>Note</p> <p>Please note that the card slot is different from a card slot used for eSD boot.</p>"},{"location":"wiki/common_boot-linux-from-sd/#4-boot-linux-on-the-board","title":"4. Boot Linux on the board","text":"<p>Press and hold power button (SW9) for 1 second to turn on the EVK. You will see the following messages in the console.</p> <pre><code>U-Boot 2021.10 (Dec 15 2023 - 06:47:44 +0000)\n\nCPU:   Renesas Electronics CPU rev 1.0\nModel: smarc-rzg2l\nDRAM:  1.9 GiB\nMMC:   sd@11c00000: 0, sd@11c10000: 1\nLoading Environment from MMC... OK\n\nIn:    serial@1004b800\nOut:   serial@1004b800\nErr:   serial@1004b800\nU-boot WDT started!\nNet:   \nError: ethernet@11c20000 address not set.\nNo ethernet found.\n\nHit any key to stop autoboot:  2  1  0 \nswitch to partitions #0, OK\nmmc1 is current device\n19857920 bytes read in 1229 ms (15.4 MiB/s)\n39079 bytes read in 6 ms (6.2 MiB/s)\nMoving Image from 0x48080000 to 0x48200000, end=49350000\n## Flattened Device Tree blob at 48000000\n   Booting using the fdt blob at 0x48000000\n   Loading Device Tree to 0000000057ff3000, end 0000000057fff6fc ... OK\n\nStarting kernel ...\n\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x412fd050]\n[    0.000000] Linux version 5.10.184-cip36-yocto-standard (oe-user@oe-host) \n...\n    (omitted)\n...\n\nPoky (Yocto Project Reference Distro) 3.1.26 smarc-rzg2l ttySC0\n\nBSP: RZG2L/RZG2L-SMARC-EVK/3.0.6-update3\nLSI: RZG2L\nVersion: 3.0.6-update3\nsmarc-rzg2l login: root\nroot@smarc-rzg2l:~#\n</code></pre> <p>You can login as root without password.</p> <p>Note</p> <p>The messages in the console depend on the EVK and software that you are using.</p> <p>If you are faced with an error in the boot process, it may be caused by u-boot configuration. See Configure U-boot.</p>"},{"location":"wiki/common_boot-linux-from-sd/#5-shutdown","title":"5. Shutdown","text":"<p>To shut down the system, run shutdown command as follows.</p> <p></p><pre><code>shutdown -h now\n</code></pre> <p>After you executing the shutdown command, it shuts down the system immediately. And when it completes, you will see the following message.</p> <pre><code>reboot: Power down\n</code></pre> <p>Then, press and hold power button (SW9) for 2 seconds to turn off the EVK.</p>"},{"location":"wiki/common_boot-linux-from-sd/#appendix","title":"Appendix","text":""},{"location":"wiki/common_boot-linux-from-sd/#configure-u-boot","title":"Configure U-boot","text":"<p>U-boot is configured for QSPI/SD boot mode by default. But if you used other modes, the configuration has been changed. In that case, initialize U-boot configuration as follows.</p> <p>Turn on the EVK, and hit any key to stop autoboot after you see the following messages in the console.</p> <pre><code>U-Boot 2021.10 (Mar 31 2022 - 03:57:20 +0000)\n\nCPU: Renesas Electronics K rev 16.10\nModel: smarc-rzg2l\nDRAM: 1.9 GiB\nMMC: sd@11c00000: 0, sd@11c10000: 1\nLoading Environment from MMC... OK\nIn: serial@1004b800\nOut: serial@1004b800\nErr: serial@1004b800\nNet:\nError: ethernet@11c20000 address not set.\nNo ethernet found.\n\nHit any key to stop autoboot:\n</code></pre> <p>Then, input the following command to restore the default configuration.</p> <p></p><pre><code>env default -a\n</code></pre> <p>Save the configuration by saveenv command.</p> <p></p><pre><code>saveenv\n</code></pre> <p>To start Linux on the EVK, press reset switch (SW10).</p>"},{"location":"wiki/common_change-display-resolution/","title":"Change display resolution","text":""},{"location":"wiki/common_change-display-resolution/#change-display-resolution","title":"Change display resolution","text":"<p>This page describes how to change display resolution for weston (window manager).</p>"},{"location":"wiki/common_change-display-resolution/#1-edit-weston-configuration-file-to-change-display-resolution","title":"1. Edit weston configuration file to change display resolution","text":"<p>Weston has a configuration file '/etc/xdg/weston/weston.ini' in the root filesystem. You can change the display resolution by editing the file.</p> <p>You can use a text editor 'vi' to change the configuration file. To open and edit the file, execute 'vi' in the terminal for Linux running on the EVK as follows. </p><pre><code>vi /etc/xdg/weston/weston.ini\n</code></pre> <p>For information about 'vi', see Linux manual page. And you can find much more information about how to use 'vi' on the internet.</p> <p>If you want to edit the configuration file on your PC, insert your microSD card into your PC. You can edit the file in your microSD card directly. It may need root privileges.</p> <p>The configuration file consists of some sections, and the section has combinations of a key and a value. </p><pre><code>[section]\nkey1=&lt;value1&gt;\nkey2=&lt;value2&gt;\n</code></pre> <p>The display resolution is configured in 'output' section, and it is set with 'name' key and 'mode' key as follows. </p><pre><code>[output]\nname=&lt;connector&gt;\nmode=&lt;width&gt;x&lt;height&gt;\n</code></pre> <p>You can also set display resolution with a refresh rate in the 'mode' key as follows. </p><pre><code>[output]\nname=&lt;connector&gt;\nmode=&lt;width&gt;x&lt;height&gt;@&lt;refresh rate&gt;\n</code></pre> <p>When you use Linux in the HMI SDK, set 'HDMI-A-1' to 'name'. For example, if you want to set a display resolution of 1920x1080 and a refresh rate of 60Hz, add the following text to the configuration file. </p>/etc/xdg/weston/weston.ini<pre><code>[output]\nname=HDMI-A-1\nmode=1920x1080@60\n</code></pre> <p>To apply the change, you need to restart weston. Execute the following command in the terminal for Linux running on the EVK. </p><pre><code>systemctl restart weston@root\n</code></pre>"},{"location":"wiki/common_change-display-resolution/#2-check-available-display-resolutions","title":"2. Check available display resolutions","text":"<p>A display monitor can support several display resolutions. You can get a list of display resolutions supported by the display monitor that you are using.</p> <p>To get a list of display resolutions, execute 'weston-info' or 'modetest'.</p>"},{"location":"wiki/common_change-display-resolution/#1-weston-info","title":"1. weston-info","text":"<p>Execute 'weston-info' in the terminal for Linux running on the EVK as follows. </p><pre><code>weston-info\n</code></pre> <p>This command outputs many messages related to weston, but you need to check only information of 'wl_output'. For example: </p><pre><code>interface: 'wl_output', version: 3, name: 17\n        x: 0, y: 0, scale: 1,\n        physical_width: 260 mm, physical_height: 150 mm,\n        make: 'GEC', model: 'Onlap1102I',\n        subpixel_orientation: unknown, output_transform: normal,\n        mode:\n                width: 1920 px, height: 1080 px, refresh: 60.000 Hz,\n                flags: current preferred\n        mode:\n                width: 1920 px, height: 1080 px, refresh: 60.000 Hz,\n                flags:\n        mode:\n                width: 1920 px, height: 1080 px, refresh: 59.940 Hz,\n                flags:\n\n...\n\n        mode:\n                width: 640 px, height: 480 px, refresh: 60.000 Hz,\n                flags:\n        mode:\n                width: 640 px, height: 480 px, refresh: 59.940 Hz,\n                flags:\n        mode:\n                width: 640 px, height: 480 px, refresh: 59.940 Hz,\n                flags:\n</code></pre> <p>In the information of 'wl_output', all available display resolution are listed. The mode with the flags 'current' is the currently used mode.</p>"},{"location":"wiki/common_change-display-resolution/#2-modetest","title":"2. modetest","text":"<p>Execute 'modetest' in the terminal for Linux running on the EVK as follows. </p><pre><code>modetest -M rzg2l-du -c\n</code></pre> <p>This command output information about connectors, and it includes a list of modes (display resolution and refresh rate). For example: </p><pre><code>Connectors:\nid      encoder status          name            size (mm)       modes   encoders\n39      38      connected       HDMI-A-1        260x150         24      38\n  modes:\n        index name refresh (Hz) hdisp hss hse htot vdisp vss vse vtot)\n  #0 1920x1080 60.00 1920 2008 2052 2200 1080 1084 1089 1125 148500 flags: phsync, pvsync; type: preferred, driver\n  #1 1920x1080 60.00 1920 2008 2052 2200 1080 1084 1089 1125 148500 flags: phsync, pvsync; type: driver\n  #2 1920x1080 59.94 1920 2008 2052 2200 1080 1084 1089 1125 148352 flags: phsync, pvsync; type: driver\n  #3 1920x1080 50.00 1920 2448 2492 2640 1080 1084 1089 1125 148500 flags: phsync, pvsync; type: driver\n  #4 1920x1080 50.00 1920 2448 2492 2640 1080 1084 1089 1125 148500 flags: phsync, pvsync; type: driver\n  #5 1680x1050 59.88 1680 1728 1760 1840 1050 1053 1059 1080 119000 flags: phsync, nvsync; type: driver\n  #6 1600x900 60.00 1600 1624 1704 1800 900 901 904 1000 108000 flags: phsync, pvsync; type: driver\n  #7 1280x1024 60.02 1280 1328 1440 1688 1024 1025 1028 1066 108000 flags: phsync, pvsync; type: driver\n  #8 1440x900 59.90 1440 1488 1520 1600 900 903 909 926 88750 flags: phsync, nvsync; type: driver\n  #9 1280x800 59.91 1280 1328 1360 1440 800 803 809 823 71000 flags: phsync, nvsync; type: driver\n  #10 1280x720 60.00 1280 1390 1430 1650 720 725 730 750 74250 flags: phsync, pvsync; type: driver\n  #11 1280x720 60.00 1280 1390 1430 1650 720 725 730 750 74250 flags: phsync, pvsync; type: driver\n  #12 1280x720 59.94 1280 1390 1430 1650 720 725 730 750 74176 flags: phsync, pvsync; type: driver\n  #13 1280x720 50.00 1280 1720 1760 1980 720 725 730 750 74250 flags: phsync, pvsync; type: driver\n  #14 1024x768 60.00 1024 1048 1184 1344 768 771 777 806 65000 flags: nhsync, nvsync; type: driver\n  #15 800x600 60.32 800 840 968 1056 600 601 605 628 40000 flags: phsync, pvsync; type: driver\n  #16 720x576 50.00 720 732 796 864 576 581 586 625 27000 flags: nhsync, nvsync; type: driver\n  #17 720x480 60.00 720 736 798 858 480 489 495 525 27027 flags: nhsync, nvsync; type: driver\n  #18 720x480 60.00 720 736 798 858 480 489 495 525 27027 flags: nhsync, nvsync; type: driver\n  #19 720x480 59.94 720 736 798 858 480 489 495 525 27000 flags: nhsync, nvsync; type: driver\n  #20 720x480 59.94 720 736 798 858 480 489 495 525 27000 flags: nhsync, nvsync; type: driver\n  #21 640x480 60.00 640 656 752 800 480 490 492 525 25200 flags: nhsync, nvsync; type: driver\n  #22 640x480 59.94 640 656 752 800 480 490 492 525 25175 flags: nhsync, nvsync; type: driver\n  #23 640x480 59.94 640 656 752 800 480 490 492 525 25175 flags: nhsync, nvsync; type: driver\n  props:\n        1 EDID:\n\n...\n</code></pre> <p>You can choose one of the modes and set it to the weston configuration file.</p>"},{"location":"wiki/common_debug-application-with-gdb/","title":"Debug application with GDB","text":""},{"location":"wiki/common_debug-application-with-gdb/#debug-application-with-gdb","title":"Debug application with GDB","text":"<p>This guide describes the use of GDB to debug programs created in C on the EVK. For more detailed information about GDB, refer to Debugging with GDB.</p> <p>You need to connect your PC to the EVK, and you need to install the following terminal program to run and debug the target program on the EVK.</p> Windows PCLinux PC <p>Tera Term (terminal software)</p> <p>FTDI VCP driver</p> <p>minicom</p>"},{"location":"wiki/common_debug-application-with-gdb/#table-of-contents","title":"Table of Contents","text":"<ul> <li>1. How to use GDB<ul> <li>1-1. Give debugging symbols and execute compilation</li> <li>1-2. Execute the created program in GDB</li> <li>1-3. Stops a program running in GDB</li> <li>1-4. Exit GDB</li> <li>1-5. Display GDB help</li> </ul> </li> <li>2. Monitor program execution<ul> <li>2-1. Interrupts the execution of the program</li> <li>2-2. Continue program execution</li> <li>2-3. Check the interruption points of the program</li> <li>2-4. Execute the program code line by line</li> <li>2-5. Check the contents of program variables</li> <li>2-6. Change program variables</li> <li>2-7. Calls a specific function linked to the program</li> <li>2-8. Return from program functions</li> </ul> </li> <li>3. Set breakpoints<ul> <li>3-1. Set breakpoints on specific lines</li> <li>3-2. Set a breakpoint in the function</li> <li>3-3. Obtain a list of breakpoints</li> <li>3-4. Disable breakpoints</li> </ul> </li> <li>4. Set watchpoints<ul> <li>4-1. Set watchpoints for variable writes</li> <li>4-2. Set watchpoints for variable reads</li> <li>4-3. Set watchpoints for reading and writing variables</li> <li>4-4. Obtain a list of watchpoints</li> <li>4-5. Disable watchpoints</li> </ul> </li> <li>5. Execute call stack<ul> <li>5-1. Obtain a backtrace of the function</li> <li>5-2. Change the stack frame</li> <li>5-3. Analyze stack frames</li> </ul> </li> <li>6. Examples<ul> <li>6-1. Example 1 of infinite loop analysis</li> <li>6-2. Example 2 of infinite loop analysis</li> <li>6-3. Segmentation Fault Analysis Example</li> </ul> </li> </ul>"},{"location":"wiki/common_debug-application-with-gdb/#1-how-to-use-gdb","title":"1. How to use GDB","text":"<p>This chapter explains how to prepare for debugging an application and how to start/stop basic GDB.  </p> <p>The gdb command is not installed in the HMI SDK environment by default. To install gdb, you need to build HMI SDK environment after changing configuration. To build HMI SDK environment, see How to Build HMI SDK. In the build procedure, modify configuration file before you run bitbake command.</p> <ol> <li> <p>Open the configuration file </p><pre><code>cd ${WORK}/build\nvim conf/local.conf\n</code></pre> </li> <li> <p>Add the following settings to the configuration files </p><pre><code>WHITELIST_GPL-3.0 += \" tools-debug gdb autoconf-native bison-native gettext-native gnu-config-native readline\"\nIMAGE_INSTALL_append = \" gdb\"\nEXTRA_IMAGE_FEATURES_append = \" tools-debug\"\n</code></pre> </li> <li> <p>Run bitbake with gdb alone to make sure no error occurs. </p><pre><code>MACHINE=${BOARD} bitbake gdb\n</code></pre> </li> <li> <p>Run bitbake to build images (See How to Build HMI SDK.)</p> </li> </ol>"},{"location":"wiki/common_debug-application-with-gdb/#1-1-give-debugging-symbols-and-execute-compilation","title":"1-1. Give debugging symbols and execute compilation","text":"<p>The -g flag must be passed to the compiler to grant debugging symbols. Add the -g flag to the Makefile. Add the -O0 flag to disable optimization.</p> <p></p>Makefile<pre><code>APP = testprog\nSRC = main.c\nall: $(APP)\nCC = gcc\nCFLAGS = -g -O0 -Wall\n$(APP):\n        $(CC) -o $(APP) $(SRC) $(CFLAGS)\nclean:\n        rm -rf $(APP)\n</code></pre> The source code should be the following. main.c<pre><code>#include &lt;stdio.h&gt;\n\nint func1(int num)\n{\n   static int sum = 0;\n   sum += num;\n   return sum;\n}\n\nint main(int argc, char** argv)\n{\n   int num;\n   num = 1;\n   while(1){\n      if(num &gt; 5000){\n         break;\n      }\n      func1(num);\n   }\n   return 0;\n}\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#1-2-execute-the-created-program-in-gdb","title":"1-2. Execute the created program in GDB","text":"<p>Execute gdb with the program compiled with the -g flag as an argument. </p><pre><code># gdb testprog\n...\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from testprog...\n(gdb)\n</code></pre> The gdb prompt will be invoked, and the program will run when the run command is executed. When specifying arguments, enter arg1, arg2, and so on. <pre><code>(gdb) run arg1 arg2\nStarting program: /home/root/debug/testprog arg1 arg2\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#1-3-stops-a-program-running-in-gdb","title":"1-3. Stops a program running in GDB","text":"<p>To stop the program, use the kill command. </p><pre><code>(gdb) kill\nKill the program being debugged? (y or n) y\n[Inferior 1 (process 46857) killed]\n(gdb)\n</code></pre> To run the program again, execute the run command. <pre><code>(gdb) run\nStarting program: /home/root/debug/testprog\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#1-4-exit-gdb","title":"1-4. Exit GDB","text":"<p>To exit GDB, use the quit command. </p><pre><code>(gdb) quit\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#1-5-display-gdb-help","title":"1-5. Display GDB help","text":"<p>If you want to check the help for GDB commands, use the help command. </p><pre><code>(gdb) help\nList of classes of commands:\n\naliases -- Aliases of other commands.\nbreakpoints -- Making program stop at certain points.\ndata -- Examining data.\nfiles -- Specifying and examining files.\ninternals -- Maintenance commands.\nobscure -- Obscure features.\nrunning -- Running the program.\nstack -- Examining the stack.\nstatus -- Status inquiries.\nsupport -- Support facilities.\ntracepoints -- Tracing of program execution without stopping the program.\nuser-defined -- User-defined commands.\n\nType \"help\" followed by a class name for a list of commands in that class.\nType \"help all\" for the list of all commands.\nType \"help\" followed by command name for full documentation.\nType \"apropos word\" to search for commands related to \"word\".\nType \"apropos -v word\" for full documentation of commands related to \"word\".\nCommand name abbreviations are allowed if unambiguous.\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-monitor-program-execution","title":"2. Monitor program execution","text":"<p>This chapter explains how to interrupt a program while it is running and proceed in the code to check and rewrite the contents of variables.</p>"},{"location":"wiki/common_debug-application-with-gdb/#2-1-interrupts-the-execution-of-the-program","title":"2-1. Interrupts the execution of the program","text":"<p>Start the program. </p><pre><code>(gdb) run\nStarting program: /home/root/debug/testprog\n</code></pre> Then Ctrl+C to send a signal and stop execution. <pre><code>^C\nProgram received signal SIGINT, Interrupt.\n0x000055555555516e in main (argc=1, argv=0x7fffffffe3a8) at main.c:16\n16          func1(num);\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-2-continue-program-execution","title":"2-2. Continue program execution","text":"<p>To continue and resume an interrupted program, use the continue command. </p><pre><code>(gdb) continue\nContinuing.\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-3-check-the-interruption-points-of-the-program","title":"2-3. Check the interruption points of the program","text":"<p>Use the list command to display the code around the point where the program was interrupted. </p><pre><code>(gdb) list\n11        int num = 1;\n12        while(1){\n13          if(num &gt; 5000){\n14            break;\n15          }\n16          func1(num);\n17        }\n18        return 0;\n19      }\n20\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-4-execute-the-program-code-line-by-line","title":"2-4. Execute the program code line by line","text":"<p>To execute one line of code at a time with the program suspended, use the next or step command. The next command advances the program one line, and if there is a function, it skips over the function call and executes the next code. </p><pre><code>(gdb) next\n16          func1(num);\n(gdb) next\n13          if(num &gt; 5000){\n</code></pre> The step command advances the program one line and moves inside the function, if any. <pre><code>(gdb) step\n16          func1(num);\n(gdb) step\nfunc1 (num=1) at main.c:4\n4       {\n(gdb) step\n6         sum += num;\n(gdb) step\n7       }\n(gdb) step\nmain (argc=1, argv=0x7fffffffe3a8) at main.c:13\n13          if(num &gt; 5000){\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-5-check-the-contents-of-program-variables","title":"2-5. Check the contents of program variables","text":"<p>To check the contents of a variable, use the print command. </p><pre><code>(gdb) print num\n$1 = 1\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-6-change-program-variables","title":"2-6. Change program variables","text":"<p>To change the contents of a variable, use the set command. </p><pre><code>(gdb) set num = 5001\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-7-calls-a-specific-function-linked-to-the-program","title":"2-7. Calls a specific function linked to the program","text":"<p>Use the call command to call any function. </p><pre><code>(gdb) call func1(1)\n(gdb) step\nfunc1 (num=1) at main.c:4\n4       {\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-8-return-from-program-functions","title":"2-8. Return from program functions","text":"<p>To terminate execution of a function in the middle of a function and return to the caller, use the finish command. The return value is also displayed when the command is executed. </p><pre><code>(gdb) finish\nRun till exit from #0  func1 (num=1) at main.c:6\nmain (argc=1, argv=0x7fffffffe3a8) at main.c:14\n14          if(num &gt; 5000){\nValue returned is $3 = 287125699\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#3-set-breakpoints","title":"3. Set breakpoints","text":"<p>This chapter describes breakpoints. A breakpoint is a landmark point at which a program is interrupted at a specific line of code. Breakpoints can be set on arbitrary lines of code or functions, and debugging is possible after interrupting the program because of step command or print command.</p>"},{"location":"wiki/common_debug-application-with-gdb/#3-1-set-breakpoints-on-specific-lines","title":"3-1. Set breakpoints on specific lines","text":"<p>When set to line If there is only one source file, specify only the number of lines. </p><pre><code>(gdb) break 14\nBreakpoint 1 at 0x1167: file main.c, line 14.\n(gdb) run\nStarting program: /home/root/debug/testprog\n\nBreakpoint 1, main (argc=1, argv=0x7fffffffe3a8) at main.c:14\n14          if(num &gt; 5000){\n(gdb)\n</code></pre> If there are multiple source files, specify the file name and number of lines. <pre><code>(gdb) break main.c:6\nBreakpoint 1 at 0x1134: file main.c, line 6.\n(gdb) run\nStarting program: /home/root/debug/testprog\n\nBreakpoint 1, func1 (num=1) at main.c:6\n6         sum += num;\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#3-2-set-a-breakpoint-in-the-function","title":"3-2. Set a breakpoint in the function","text":"<p>When setting to a function, specify the function name. </p><pre><code>(gdb) break func1\nBreakpoint 1 at 0x1129: file main.c, line 4.\n(gdb) run\nStarting program: /home/root/debug/testprog\n\nBreakpoint 1, func1 (num=21845) at main.c:4\n4       {\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#3-3-obtain-a-list-of-breakpoints","title":"3-3. Obtain a list of breakpoints","text":"<p>Use the info breakpoints command to display a list of all currently set breakpoints. </p><pre><code>(gdb) info breakpoint\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep y   0x0000555555555129 in func1 at main.c:4\n        breakpoint already hit 1 time\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#3-4-disable-breakpoints","title":"3-4. Disable breakpoints","text":"<p>Use the disable command to disable the currently set breakpoint. The argument must be a breakpoint number to be obtained with info breakpoints. Disabled breakpoints will have an Enb of n. run execution will not stop at breakpoints. </p><pre><code>(gdb) disable 1\n(gdb) info breakpoints\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep n   0x0000555555555129 in func1 at main.c:4\n        breakpoint already hit 1 time\n(gdb) run\nStarting program: /home/root/debug/testprog\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#4-set-watchpoints","title":"4. Set watchpoints","text":"<p>This chapter describes the watchpoints. A watchpoint is a marker point at which the program is interrupted when a variable is accessed. Watchpoints can be set on arbitrary variables, and debugging is possible after interrupting the program because of step command or print command.</p>"},{"location":"wiki/common_debug-application-with-gdb/#4-1-set-watchpoints-for-variable-writes","title":"4-1. Set watchpoints for variable writes","text":"<p>If you want to interrupt the program when writing to a specific variable, use the watch command. Since the variable to be specified must be in the current scope, it should be used in conjunction with breakpoints.</p> <p>Set a breakpoint in the main function. </p><pre><code>(gdb) break main\nBreakpoint 1 at 0x114d: file main.c, line 11.\n(gdb) run\nStarting program: /home/root/debug/testprog\n\nBreakpoint 1, main (argc=21845, argv=0x0) at main.c:11\n11      {\n</code></pre> Set watchpoints in the num variable. <pre><code>(gdb) watch num\nHardware watchpoint 2: num\n(gdb) continue\nContinuing.\n</code></pre> Stops when writing num variables. <pre><code>Hardware watchpoint 2: num\n\nOld value = 0\nNew value = 1\nmain (argc=1, argv=0x7fffffffe3a8) at main.c:14\n14          if(num &gt; 5000){\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#4-2-set-watchpoints-for-variable-reads","title":"4-2. Set watchpoints for variable reads","text":"<p>If you want to interrupt the program when a specific variable is read, use the rwatch command. Usage notes are the same as for the watch command.</p> <p>Set a breakpoint in the func1 function. </p><pre><code>(gdb) break func1\nBreakpoint 1 at 0x1129: file main.c, line 4.\n(gdb) run\nStarting program: /home/root/debug/testprog\n\nBreakpoint 1, func1 (num=21845) at main.c:4\n4       {\n</code></pre> Stops when sum variable is read. <pre><code>(gdb) rwatch sum\nHardware read watchpoint 2: sum\n(gdb) continue\nContinuing.\n\nHardware read watchpoint 2: sum\n\nValue = 0\n0x000055555555513a in func1 (num=1) at main.c:6\n6         sum += num;\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#4-3-set-watchpoints-for-reading-and-writing-variables","title":"4-3. Set watchpoints for reading and writing variables","text":"<p>If you want to interrupt the program when either reading or writing a specific variable occurs, use the awatch command. Usage notes are the same as for the watch command.</p> <p>Set a breakpoint in the func1 function. </p><pre><code>(gdb) break func1\nBreakpoint 1 at 0x1129: file main.c, line 4.\n(gdb) run\nStarting program: /home/root/debug/testprog\n\nBreakpoint 1, func1 (num=21845) at main.c:4\nwarning: Source file is more recent than executable.\n4       {\n</code></pre> Stops when reading/writing sum variables. <pre><code>(gdb) awatch sum\nHardware access (read/write) watchpoint 2: sum\n(gdb) continue\nContinuing.\n</code></pre> Stop at readout. <pre><code>Hardware access (read/write) watchpoint 2: sum\n\nValue = 0\n0x000055555555513a in func1 (num=1) at main.c:6\n6         sum += num;\n(gdb) continue\nContinuing.\n</code></pre> Stop when writing. <pre><code>Hardware access (read/write) watchpoint 2: sum\n\nOld value = 0\nNew value = 1\nfunc1 (num=1) at main.c:7\n7         return sum;\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#4-4-obtain-a-list-of-watchpoints","title":"4-4. Obtain a list of watchpoints","text":"<p>Use the info breakpoints command to display a list of all currently set watchpoints. </p><pre><code>(gdb) info breakpoints\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep y   0x0000555555555129 in func1 at main.c:4\n        breakpoint already hit 1 time\n2       acc watchpoint keep y                      sum\n        breakpoint already hit 2 times\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#4-5-disable-watchpoints","title":"4-5. Disable watchpoints","text":"<p>Use the disable command to disable the currently set watchpoints. The argument must be a watchpoint number to be obtained with info breakpoints. Disabled watchpoints will have an Enb of n. run execution will not stop at the watchpoint. </p><pre><code>(gdb) disable 2\n(gdb) info breakpoints\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep y   0x0000555555555129 in func1 at main.c:4\n        breakpoint already hit 1 time\n2       acc watchpoint keep n                      sum\n        breakpoint already hit 2 times\n(gdb) continue\nContinuing.\n\nBreakpoint 1, func1 (num=1) at main.c:4\n4       {\n(gdb) continue\nContinuing.\n\nBreakpoint 1, func1 (num=1) at main.c:4\n4       {\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#5-execute-call-stack","title":"5. Execute call stack","text":"<p>This chapter explains how to analyze stacked frames. The execution status of the function can be checked by analyzing the stack frame.</p>"},{"location":"wiki/common_debug-application-with-gdb/#5-1-obtain-a-backtrace-of-the-function","title":"5-1. Obtain a backtrace of the function","text":"<p>Use the backtrace command to obtain a backtrace, which is information about the caller of a function. </p><pre><code>(gdb) backtrace\n#0  func1 (num=1) at main.c:4\n#1  0x000055555555517a in main (argc=1, argv=0x7fffffffe3a8) at main.c:17\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#5-2-change-the-stack-frame","title":"5-2. Change the stack frame","text":"<p>To change the stack frame, use the frame command. Get the frame number with the backtrace command and use it as an argument. </p><pre><code>(gdb) frame 1\n#1  0x000055555555517a in main (argc=1, argv=0x7fffffffe3a8) at main.c:17\n17          func1(num);\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#5-3-analyze-stack-frames","title":"5-3. Analyze stack frames","text":"<p>Three commands to check the contents of the current stack frame are described. The info frame command outputs detailed information such as register values for the current stack frame. </p><pre><code>(gdb) info frame\nStack level 1, frame at 0x7fffffffe2c0:\n rip = 0x55555555517a in main (main.c:17); saved rip = 0x7ffff7de4083\n caller of frame at 0x7fffffffe290\n source language c.\n Arglist at 0x7fffffffe288, args: argc=1, argv=0x7fffffffe3a8\n Locals at 0x7fffffffe288, Previous frame's sp is 0x7fffffffe2c0\n Saved registers:\n  rbp at 0x7fffffffe2b0, rip at 0x7fffffffe2b8\n(gdb)\n</code></pre> The info locals command displays a list of local variables and their values for the current stack frame. <pre><code>(gdb) info locals\nnum = 1\n(gdb)\n</code></pre> The info args command displays a list of arguments for the current stack frame. <pre><code>(gdb) info args\nargc = 1\nargv = 0x7fffffffe3a8\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#6-examples","title":"6. Examples","text":""},{"location":"wiki/common_debug-application-with-gdb/#6-1-example-1-of-infinite-loop-analysis","title":"6-1. Example 1 of infinite loop analysis","text":"<p>The source code should be the following. The value of num is added and the program terminates when it exceeds 5000.</p> <p></p>main.c<pre><code>#include &lt;stdio.h&gt;\n\nint func1(int num)\n{\n   static int sum = 0;\n   sum += num;\n   return sum;\n}\n\nint main(int argc, char** argv)\n{\n   int num;\n   num = 1;\n   while(1){\n      if(num &gt; 5000){\n         break;\n      }\n      func1(num);\n   }\n   return 0;\n}\n</code></pre> Compile the program with the -g option. When the program is executed, it falls into an infinite loop. <pre><code># ./testprog\n</code></pre> Debugging with gdb. <pre><code># gdb testprog\n...\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from testprog...\n(gdb) run\nStarting program: /home/root/debug/testprog\n</code></pre> The program is interrupted by Ctrl+C because it falls into an infinite loop. <pre><code>^C\nProgram received signal SIGINT, Interrupt.\nfunc1 (num=1) at main.c:8\n8       }\n(gdb)\n</code></pre> Advance the program with the next command. <pre><code>(gdb) next\nmain (argc=1, argv=0x7fffffffe3a8) at main.c:15\n15          if(num &gt; 5000){\n(gdb) next\n18          func1(num);\n(gdb) next\n15          if(num &gt; 5000){\n(gdb) next\n18          func1(num);\n(gdb) next\n15          if(num &gt; 5000){\n(gdb)\n</code></pre> The same pattern is repeated, and this code does not update the value of num. Since the condition for exiting the loop is that num must exceed 5000, the fact that num did not change was the cause of the infinite loop. <pre><code>      if(num &gt; 5000){\n         break;\n      }\n</code></pre> The func1 function adds the value of num to sum and returns it, so the expected behavior is to receive that value in the main function. <pre><code>int func1(int num)\n{\n   static int sum = 0;\n   sum += num;\n   return sum;\n}\n</code></pre> <pre><code>while(1){\n   if(num &gt; 5000){\n      break;\n   }\n   num = func1(num);\n}\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#6-2-example-2-of-infinite-loop-analysis","title":"6-2. Example 2 of infinite loop analysis","text":"<p>The source code should be the following. This program stores 300 values calculated from a counter in an array of ints.</p> <p></p>main.c<pre><code>#include &lt;stdio.h&gt;\n\n#define DATANUM 300\n\nint getdata(unsigned char cnt)\n{\n  return (int)cnt*(cnt+cnt);\n}\n\nint main(int argc, char** argv)\n{\n  unsigned char cnt = 0;\n  int data[DATANUM];\n\n  for(cnt = 0;cnt &lt; DATANUM;cnt++){\n    data[cnt] = getdata(cnt);\n  }\n\n  return 0;\n}\n</code></pre> Compile the program with the -g option.  When the program is executed, it falls into an infinite loop. <pre><code># ./testprog\n</code></pre> Debugging with gdb. <pre><code># gdb testprog\n...\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from testprog...\n(gdb) run\nStarting program: /home/root/debug/testprog\n</code></pre> The program is interrupted by Ctrl+C because it falls into an infinite loop. <pre><code>^C\nProgram received signal SIGINT, Interrupt.\ngetdata (cnt=106 'j') at main3.c:6\n6       {\n(gdb)\n</code></pre> Since the loop does not end, we confirmed that if we advance the program with the step command until cnt reaches 300, which is the intended end condition, cnt returns to 0 in the middle of the loop. <pre><code>(gdb)step\ngetdata (cnt=255 '\\377') at main3.c:6\n6       {\n(gdb)step\n7         return (int)cnt*(cnt+cnt);\n(gdb)step\n8       }\n(gdb)step\nmain (argc=1, argv=0x7fffffffe3a8) at main3.c:15\n15        for(cnt = 0;cnt &lt; DATANUM;cnt++){\n(gdb)step\n16          data[cnt] = getdata(cnt);\n(gdb)step\ngetdata (cnt=0 '\\000') at main3.c:6\n6       {\n(gdb)\n</code></pre> The fact that cnt returns to 0 at 255 means that cnt cannot hold more than 256, so the counter variable may not be of the correct type. I checked the counter variable and found that cnt is defined as unsigned char (0-255). This would have resulted in an infinite loop because the loop termination condition of 300 would never be reached. <pre><code>unsigned char cnt = 0;\n</code></pre> The expected behavior is achieved by setting the type of cnt to unsigned short (0-65535)."},{"location":"wiki/common_debug-application-with-gdb/#6-3-segmentation-fault-analysis-example","title":"6-3. Segmentation Fault Analysis Example","text":"<p>The source code should be the following. Allocates memory with malloc and initializes buffers.</p> <p></p>main.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char** argv)\n{\n  char *buf;\n  buf = malloc(1&lt;&lt;31);\n  memset(buf,0x00,1024);\n  return 0;\n}\n</code></pre> Compile the program with the -g option. Segmentation fault occurs when the program is executed. <pre><code># ./testprog\nSegmentation fault (core dumped)\n</code></pre> Debugging with gdb. <pre><code># gdb testprog\n...\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from testprog...\n(gdb) run\nStarting program: /home/root/debug/testprog\n\nProgram received signal SIGSEGV, Segmentation fault.\n__memset_avx2_unaligned_erms () at ../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:200\n200     ../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S: No such file or directory.\n(gdb)\n</code></pre> Check backtrace as SIGSEGV occurs. <pre><code>(gdb) backtrace\n#0  __memset_avx2_unaligned_erms () at ../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:200\n#1  0x00005555555551a2 in main (argc=1, argv=0x7fffffffe3a8) at main.c:9\n(gdb)\n</code></pre> Segmentation fault occurs at line 9 of the code, so the frame is switched. <pre><code>(gdb) frame 1\n#1  0x00005555555551a2 in main (argc=1, argv=0x7fffffffe3a8) at main.c:9\n9         memset(buf,0x00,1024);\n(gdb)\n</code></pre> Segmentation fault occurs in memset, so I check the buf contents and the buf address is NULL. <pre><code>(gdb) print buf\n$1 = 0x0\n(gdb)\n</code></pre> Once the program is finished, set a breakpoint in the main function and a watchpoint in buf. <pre><code>(gdb) kill\nKill the program being debugged? (y or n) y\n[Inferior 1 (process 47511) killed]\n(gdb) break main\nBreakpoint 1 at 0x555555555169: file main.c, line 6.\n(gdb) run\nStarting program: /home/pokyuser/hello_apl/testprog\n\nBreakpoint 1, main (argc=21845, argv=0x0) at main.c:6\n6       {\n(gdb) awatch buf\nHardware access (read/write) watchpoint 2: buf\n(gdb)\n</code></pre> Checking the buf pointer change, it remains NULL even after allocating memory with malloc. <pre><code>(gdb) continue\nContinuing.\n\nHardware access (read/write) watchpoint 2: buf\n\nValue = 0x0\nmain (argc=1, argv=0x7fffffffe3a8) at main.c:9\n9         memset(buf,0x00,1024);\n(gdb) continue\nContinuing.\n\nHardware access (read/write) watchpoint 2: buf\n\nValue = 0x0\n0x0000555555555190 in main (argc=1, argv=0x7fffffffe3a8) at main.c:9\n9         memset(buf,0x00,1024);\n(gdb) continue\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n__memset_avx2_unaligned_erms () at ../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:200\n200     ../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S: No such file or directory.\n(gdb)\n</code></pre> Check the malloc function to confirm that malloc is specified to return NULL if memory cannot be allocated. <pre><code>buf = malloc(1&lt;&lt;31);\n</code></pre> The memory size being allocated by malloc was 4 GB, and NULL was returned because the huge size was not allocated. Since the size set in memset is 1024 bytes, the problem can be solved by either setting the size to be acquired by malloc to 1024 as well or checking the return value of malloc, and if it is NULL, do not access it, etc."},{"location":"wiki/common_update-firmware/","title":"Update firmware (bootloaders) on EVK","text":""},{"location":"wiki/common_update-firmware/#update-firmware-bootloaders-on-evk","title":"Update firmware (bootloaders) on EVK","text":"<p>When you use QSPI boot mode or eMMC boot mode, you should update firmware (bootloaders). This page describes how to write flash writer and bootloaders. To write flash writer and bootloaders, you need to connect your PC to the EVK with a USB serial cable. See \"Setup EVK's peripheral\". And The following tools are used in this instructions. Please install them to your PC in advance.</p> Windows PCLinux PC <p>Tera Term (terminal software)</p> <p>FTDI VCP driver</p> <p>minicom</p> <p>For information about how to use QSPI boot, see Boot Linux from microSD card. And for information about how to use eMMC boot, refer to RZ/G2L, RZ/G2LC and RZ/G2UL-EVKIT Linux Start-up Guide.</p>"},{"location":"wiki/common_update-firmware/#1-set-boot-mode-to-scif-download-mode","title":"1. Set boot mode to SCIF download mode","text":"<p>Turn off the power of EVK, then set the SW11 as follows.</p> <p></p> SW11-1 SW11-2 SW11-3 SW11-4 OFF ON OFF ON"},{"location":"wiki/common_update-firmware/#2-configure-terminal-software","title":"2. Configure terminal software","text":"<p>Configure the setting of serial communication on terminal software as follows:</p> <ul> <li>Speed: 115200 bps</li> <li>Data: 8bit</li> <li>Parity: None</li> <li>Stop bit: 1 bit</li> <li>Flow control: None</li> </ul>"},{"location":"wiki/common_update-firmware/#3-prepare-flash-writer-and-bootloaders","title":"3. Prepare flash writer and bootloaders","text":"<p>The flash writer and the bootloaders are stored in the pre-built binaries package of the HMI SDK.  See file contents.</p> <p>Unzip the pre-built binaries package to pick up flash write and bootloaders as follows:</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p><pre><code>unzip pre-built-binary_rzg2l_hmi-sdk_v*.zip\n</code></pre> <ul> <li> <p>Flash writer</p> <ul> <li>Flash_Writer_SCIF_RZG2L_SMARC_PMIC_DDR4_2GB_1PCS.mot</li> </ul> </li> <li> <p>Bootloaders</p> <ul> <li>bl2_bp-smarc-rzg2l_pmic.srec</li> <li>fip-smarc-rzg2l_pmic.srec</li> </ul> </li> </ul> <p></p><pre><code>unzip pre-built-binary_rzg2lc_hmi-sdk_v*.zip\n</code></pre> <ul> <li> <p>Flash writer</p> <ul> <li>Flash_Writer_SCIF_RZG2LC_SMARC_DDR4_1GB_1PCS.mot</li> </ul> </li> <li> <p>Bootloaders</p> <ul> <li>bl2_bp-smarc-rzg2lc.srec</li> <li>fip-smarc-rzg2lc.srec</li> </ul> </li> </ul> <p></p><pre><code>unzip pre-built-binary_rzg2ul_hmi-sdk_v*.zip\n</code></pre> <ul> <li> <p>Flash writer</p> <ul> <li>Flash_Writer_SCIF_RZG2UL_SMARC_DDR4_1GB_1PCS.mot</li> </ul> </li> <li> <p>Bootloaders</p> <ul> <li>bl2_bp-smarc-rzg2ul.srec</li> <li>fip-smarc-rzg2ul.srec</li> </ul> </li> </ul>"},{"location":"wiki/common_update-firmware/#4-download-flash-writer-to-ram","title":"4. Download flash writer to RAM","text":"<p>Turn on the power of the EVK by pressing SW9. The messages below are shown on the terminal.</p> <pre><code> SCIF Download mode\n (C) Renesas Electronics Corp.\n-- Load Program to System RAM ---------------\nplease send !\n</code></pre> <p>Send an image of flash writer using terminal software after the message \"please send !\" is shown.</p> Windows PC (Tera Term)Linux PC (minicom) <p>Open the \"File\" menu, then select \"Send file...\" to open \"Send file\" dialg.</p> <p>Select the flash writer image in the dialog, and press \"Open\" button.</p> <p>Press \"Ctrl + A\", and \"S\", then select \"ascii\" for upload mode.</p> <p>Select the flash writer image file.</p> <p>Press any key when upload is completed.</p> <p>After successfully downloading the image, the flash writer starts automatically and shows a message like below on the terminal. </p><pre><code>Flash writer for RZ/G2 Series V1.06 Aug.10,2022                                                    \n Product Code : RZ/G2UL Type1   \n&gt;\n</code></pre>"},{"location":"wiki/common_update-firmware/#5-write-the-bootloaders","title":"5. Write the bootloaders","text":""},{"location":"wiki/common_update-firmware/#5-1-change-baud-rate-of-serial-port","title":"5-1. Change baud rate of serial port","text":"<p>Before writing the loader files, change the flash writer transfer rate from default (115200bps) to high speed (921600bps) with \"SUP\" command. </p><pre><code>SUP\n</code></pre> <p>After the \"SUP\" command, change the serial communication protocol speed from 115200bps to 921600bps on the terminal software.</p>"},{"location":"wiki/common_update-firmware/#5-2-write-bl2-file","title":"5-2. Write bl2 file","text":"<p>Execute \"XLS2\" command to write boot loader binary files.  </p><pre><code>XLS2\n</code></pre> <p>This command receives binary data from the serial port and writes the data to a specified address of the Flash ROM with information where the data should be loaded on the address of the main memory.  Set the following addresses respectively.</p> <ul> <li>Address to load to RAM: H'11E00</li> <li>Address to save to ROM: H'00000</li> </ul> <p>For example: </p><pre><code>&gt;XLS2                                                                                              \n===== Qspi writing of RZ/G2 Board Command =============                                            \nLoad Program to Spiflash                                                                           \nWrites to any of SPI address.                                                                      \n Dialog : AT25QL128A                                                                               \nProgram Top Address &amp; Qspi Save Address                                                            \n===== Please Input Program Top Address ============                                                \n  Please Input : H'11E00                                                                           \n                                                                                                   \n===== Please Input Qspi Save Address ===                                                           \n  Please Input : H'00000                                                                           \nWork RAM(H'50000000-H'53FFFFFF) Clear....                                                          \nplease send ! ('.' &amp; CR stop load)\n</code></pre> <p>Send the data of \"bl2_bp-smarc-rzg2*.srec\" from terminal software in the same way as the flash writer after the message \"please send !\" is shown.  For the actual file name of bl2 file, see 3. Prepare flash writer and bootloaders.</p> <p>In the case that the following message is shown, enter 'y'. </p><pre><code>SPI Data Clear(H'FF) Check :H'00000000-0000FFFF,Clear OK?(y/n)\n</code></pre> <p>After writing the data is completed, the following messages like below are shown on the terminal. </p><pre><code>SPI Data Clear(H'FF) Check :H'00000000-0000FFFF Erasing..Erase Completed \nSAVE SPI-FLASH.......\n======= Qspi  Save Information  =================\n SpiFlashMemory Stat Address : H'00000000\n SpiFlashMemory End Address  : H'0000CA38\n===========================================================\n\n&gt;\n</code></pre>"},{"location":"wiki/common_update-firmware/#5-3-write-fip-file","title":"5-3. Write fip file","text":"<p>Execute \"XLS2\" command to write fip file.  </p><pre><code>XLS2\n</code></pre> <p>Set the following addresses respectively for the fip file.</p> <ul> <li>Address to load to RAM: H'00000</li> <li>Address to save to ROM: H'1D200</li> </ul> <p>For example: </p><pre><code>&gt;XLS2\n===== Qspi writing of RZ/G2 Board Command =============\nLoad Program to Spiflash\nWrites to any of SPI address.\n Dialog : AT25QL128A\nProgram Top Address &amp; Qspi Save Address \n===== Please Input Program Top Address ============\n  Please Input : H'00000\n \n===== Please Input Qspi Save Address ===\n  Please Input : H'1D200\nWork RAM(H'50000000-H'53FFFFFF) Clear....\nplease send ! ('.' &amp; CR stop load)\n</code></pre> <p>Send the data of \"fip-smarc-rzg2*.srec\" from terminal software in the same way as the flash writer after the message \"please send !\" is shown.  For the actual file name of fip file, see 3. Prepare flash writer and bootloaders.</p> <p>In the case that the following message is shown, enter 'y'. </p><pre><code>SPI Data Clear(H'FF) Check :H'00010000-000DFFFF,Clear OK?(y/n)\n</code></pre> <p>After writing the data is completed, the following messages like below are shown on the terminal. </p><pre><code>SPI Data Clear(H'FF) Check :H'00010000-000DFFFF Erasing..............Erase Completed \nSAVE SPI-FLASH.......\n======= Qspi  Save Information  =================\n SpiFlashMemory Stat Address : H'0001D200\n SpiFlashMemory End Address  : H'000DD9EF\n===========================================================\n\n&gt;\n</code></pre>"},{"location":"wiki/common_update-firmware/#5-4-restore-baud-rate-of-serial-port","title":"5-4. Restore baud rate of serial port","text":"<p>After writing two loader files is completed, restore the serial communication protocol speed to 115200bps on the terminal software. Then, turn off the power of the board by pressing the SW9.</p>"},{"location":"wiki/common_update-linux-package/","title":"Update Linux Package in HMI SDK","text":""},{"location":"wiki/common_update-linux-package/#update-linux-package-in-hmi-sdk","title":"Update Linux Package in HMI SDK","text":"<p>The HMI SDK is configured using RZ/G Verified Linux Package (hereinafter referred to as \"VLP/G\") or Board Support Package (hereinafter referred to as \"BSP\"). When the VLP/G or the BSP in the HMI SDK is updated to fix issues, you can replace the VLP/G or the BSP with new one.</p>"},{"location":"wiki/common_update-linux-package/#updates-of-vlpg-v307","title":"Updates of VLP/G v3.0.7","text":"<p>HMI SDK v2.3.1.0 uses VLP/G v3.0.7, but some issues were detected in the VLP/G. VLP/G v3.0.7-update3 was released to address vulnerabilities and improve drivers in VLP/G v3.0.7.</p>"},{"location":"wiki/common_update-linux-package/#changes","title":"Changes","text":"<p>Changes in VLP/G v3.0.7-update3 are listed below.</p> Features Description Kernel The VLP/G v3.0.7-update3 includes several minor kernel fixes. U-Boot Update vmmc and vqmmc settings for eSD mode. Configure U-Boot to set a random MAC address. CVE-2024-53104 Fix out-of-bounds write by skipping UVC_VS_UNDEFINED frame parsing in uvc_parse_format (media: uvcvideo). CVE-2025-4802 The VLP/G v3.0.7-update3 includes the patch for the glibc vulnerability. glib-2.0 Updated to glib2.0_2.58.3-2+deb10u8. multimedia Update runtime dependencies, fix MMNGR issues, and add GRAY10_LE64 support to GStreamer. attr, binutils, busybox, coreutils, gcc-8, gnupg2, gzip, kbd, libassuan, libgcrypt20, libunistring, nss, openssh, openssl, perl, pkg-config, pseudo, quilt Switch to the ELTS mirror to prevent removal from the Debian Buster mirror:  - attr, coreutils, gcc-8, gnupg2, gzip, kbd, libassuan, libgcrypt20, libunistring, nss, perl, pkg-config, pseudo, quilt  Upgraded packages:  - binutils 2.31.1-16 -&gt; 2.31.1-16+deb10u1  - busybox 1.30.1-4 -&gt; 1.30.1-4+deb10u1  - openssh 7.9p1-10+deb10u2 -&gt; 7.9p1-10+deb10u5  - openssl 1.1.1n-0+deb10u6 -&gt; 1.1.1n-0+deb10u7 SSI Driver Fix random recording failures in full-duplex communication mode (RZ/G2L Series and RZ/G3S). PCIe Driver Enables NVMe PCIe support (RZ/G3S only). <p>For more detailed information about VLP/G v3.0.7-update3, get RZ/G Verified Linux Package v3.0.7 (RTK0EF0045Z0021AZJ-v3.0.7-update3) and check the release note in the package.</p>"},{"location":"wiki/common_update-linux-package/#how-to-update-vlpg-from-v307-to-v307-update3","title":"How to Update VLP/G from v3.0.7 to v3.0.7-update3","text":"<p>To update VLP/G v3.0.7 in HMI SDK v2.3.1.0, build the HMI SDK by following the instructions below.</p>"},{"location":"wiki/common_update-linux-package/#i-first-perform-instructions-at-step-1-and-1-through-4-at-step-2-in-how-to-build-hmi-sdk","title":"i. First, perform instructions at step 1 and #1 through #4 at step 2 in How To Build HMI SDK.","text":"<p>Note</p> <p>You do not need to download the HMI SDK source code package at step 1. Due to the update of the VLP/G, source codes of some modules were updated. So, you will get new source codes over a network in this build process.</p>"},{"location":"wiki/common_update-linux-package/#ii-next-replace-meta-renesas-with-new-one-as-follows","title":"ii. Next, replace meta-renesas with new one as follows:","text":"<pre><code>cd ${WORK}\nrm -rf meta-renesas\ngit clone https://github.com/renesas-rz/meta-renesas.git\ncd meta-renesas/\ngit checkout -b tmp BSP-3.0.7-update3\n</code></pre>"},{"location":"wiki/common_update-linux-package/#iii-then-proceed-with-5-through-8-at-step-2-in-how-to-build-hmi-sdk-but-skip-7-at-step-2","title":"iii. Then, proceed with #5 through #8 at step 2 in How To Build HMI SDK, but skip #7 at step 2.","text":"<p>Note</p> <p>You can skip #7 at step 2 because it shows instructions for offline build using the source code package.</p>"},{"location":"wiki/common_update-linux-package/#iv-finally-run-bitbake-command-to-build-images","title":"iv. Finally, run <code>bitbake</code> command to build images.","text":"RZ/G2LRZ/G2LCRZ/G2UL <pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston\n</code></pre> <p>Note</p> <p>A change of EMMC setting in #9 at step 2 is no longer necessary for VLP/G v3.0.7-update3.</p> <p>If you need to create an SDK toolchain, run <code>bitbake</code> command as follows. </p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston -c populate_sdk\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston\n</code></pre> <p>Note</p> <p>A change of SW_SD0_DEV_SEL setting in #9 at step 2 is no longer necessary for VLP/G v3.0.7-update3.</p> <p>If you need to create an SDK toolchain, run <code>bitbake</code> command as follows. </p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston -c populate_sdk\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-bsp\n</code></pre> <p>If you need to create an SDK toolchain, run <code>bitbake</code> command as follows. </p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-bsp -c populate_sdk\n</code></pre> <p>After building images or SDK toolchain, you can find them in the following directories, respectively.</p> <ul> <li>Images: <code>${WORK}/build/tmp/deploy/images/${BOARD}/</code></li> <li>SDK toolchain: <code>${WORK}/build/tmp/deploy/sdk/</code></li> </ul>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/","title":"Develop LVGL GUI applications using EEZ Studio","text":""},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#develop-lvgl-gui-applications-using-eez-studio","title":"Develop LVGL GUI applications using EEZ Studio","text":"<p>EEZ Studio is a free and cross-platform tool that can be used for development of LVGL GUIs. It is an open-source tool licensed under GPL v3.</p> <p>This guide describes the use of EEZ Studio to develop LVGL GUI applications. For detailed information about EEZ Studio, see EEZ Studio documentation because this guide provides only basic information.</p>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#installation","title":"Installation","text":""},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#in-the-case-of-windows-pc","title":"In the case of Windows PC","text":"<ol> <li> <p>Get the EEZ Studio installer 'EEZ-Studio-Setup-x.xx.x.exe' from the GitHub page.   </p> </li> <li> <p>Double-click the downloaded installer and agree to the software license agreement to start installation.</p> </li> </ol>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#in-the-case-of-linux-pc-ubuntu","title":"In the case of Linux PC (Ubuntu)","text":"<ol> <li> <p>Get the EEZ Studio installer 'eezstudio_x.xx.x_amd64.deb' from the GitHub page. If you cannot find the installer in the list, click 'Show all xx assets' at the bottom of the list to show all items.   </p> </li> <li> <p>Double-click the downloaded installer and click the Install button.   </p> </li> <li> <p>Enter the login password and click Authenticate to start the installation.   </p> </li> </ol>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#development-of-gui","title":"Development of GUI","text":"<p>The development flow described in this guide is as follows.</p> <ol> <li>Create GUI and generate source code in EEZ Studio on your PC.</li> <li>Build the GUI application from the generated source code on your Linux PC.</li> <li>Copy the built executable file into a microSD card and run it on the EVK.</li> </ol>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#1-create-gui-and-generate-source-code","title":"1. Create GUI and Generate source code","text":"<p>You can create LVGL GUI applications using EEZ Studio on your PC. And it supports generating source code.</p>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#creating-a-project","title":"Creating a project","text":"<ol> <li> <p>Start EEZ Studio, select \"File\" on the left tab and choose \"New Project\".   </p> </li> <li> <p>Select \"LVGL\" and enter an arbitrary project name in PROJECT SETTINGS and press Create Project.   </p> </li> </ol>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#creating-gui","title":"Creating GUI","text":"<ol> <li> <p>Adding widgets Drag and drop the necessary widgets (e.g. Arc) from the Components Palettes.    </p> </li> <li> <p>Change the size and display of widgets You can resize the widgets (e.g. Arc) by expanding the blue frame.    You can also change the size from POSITION AND SIZE in widgets (e.g. Arc).   </p> <ul> <li>Left - Move widgets left and right.</li> <li>Top - Move widgets up and down.</li> <li>Width - Set the width of widgets.</li> <li>Height - Set the height of widgets.  SPECIFIC in WIDGETS (e.g. Arc) to change the way it is displayed. SPECIFIC has different items that can be changed depending on the widgets displayed.   </li> <li>Range min - Minimum value of range</li> <li>Range max - Maximum value of range</li> <li>Value - Length of the blue line (depends on the application.)</li> <li>Bg start angle - Starting point of the blue line</li> <li>Bg end angle - End of the blue line</li> <li>Mode - Select from three types.  NORMAL appears at the fixed position of the blue line, SYMMETRICAL at the symmetrical position of the fixed position of the blue line, and REVERSE at the exact opposite position of the fixed position of the blue line.</li> </ul> </li> <li> <p>Adding image files Click on bitmaps on the right and drag and drop image files from Explorer into the red box.   </p> </li> <li> <p>Apply image to widgets (image). Drag and drop the necessary widgets (image) from the Components Palettes.     Add the image files added in Add Image Files.   </p> </li> <li> <p>Apply image to widgets (imagebutton). Drag and drop the necessary widgets (imagebutton) from the Components Palettes.     Add the image files added in Add Image Files.   </p> </li> </ol>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#generating-c-source-code","title":"Generating C source code","text":"<ol> <li> <p>Open the created UI project in EEZ Studio   </p> </li> <li> <p>Generate source code by following the steps below.</p> <ul> <li> <p>2.1. Preservation</p> </li> <li> <p>2.2. Check the settings.</p> </li> <li> <p>2.3. Build and generate source code </p> </li> </ul> </li> <li> <p>Source code is generated. Source files are generated in the source folder in the project within eez-project.   </p> </li> </ol>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#implementation-of-events","title":"Implementation of events","text":"<ol> <li> <p>Follow the steps below to set up events using the UI in EEZ Studio.</p> <ol> <li> <p>Press \"+\" for \"event handlers\" in the properties of the object for which you want to set events. </p> </li> <li> <p>Select \"New Action\" and set the event name. </p> </li> <li> <p>Go to \"User Actions\", select the event created in the previous step, and copy the generated event callback template to screen.c. </p> </li> </ol> </li> <li> <p>Implement the generated event callback in C language. In this example, color of the button is changed in the event callback function.</p> </li> </ol> <pre><code>void action_push(lv_event_t *e) {\n\tlv_obj_t btn = lv_event_get_target(e);\n\n\tlv_obj_set_style_bg_color(btn, lv_color_hex(0xfff6e01d), LV_PART_MAIN | LV_STATE_DEFAULT);\n}\n</code></pre>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#implementation-of-screen-transitions","title":"Implementation of screen transitions","text":"<ul> <li> <p>For screen transitions, a screen ID is assigned to each page in screen.h when a multi-page UI is created in EEZ Studio. </p>screen.h<pre><code>enum ScreensEnum {\n\tSCREEN_ID_MAIN = 1,\n\tSCREEN_ID_SECOND = 2,\n};\n</code></pre> </li> <li> <p>To perform screen transitions, implement them in the event callbacks by yourself using the C language. In this example, screen transition is implemented in an event callback is. </p><pre><code>void action_push(lv_event_t *e) {\n\tloadScreen(SCREEN_ID_SECOND);\n}\n</code></pre> </li> </ul>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#2-build-lvgl-gui-applications","title":"2. Build LVGL GUI applications","text":"<p>You can build LVGL GUI applications from the generated source code. Please note that you need to build the applications on a Linux PC.</p>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#setting-up-cross-compiler","title":"Setting up cross compiler","text":"<p>Install cross compiler to your Linux PC, and enable the compiler. To install and enable the compiler, see Step 6: Build sample application.</p>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#building-gui-application","title":"Building GUI application","text":"<ol> <li> <p>Add \"main.c\" to the generated \u201csrc/ui folder. An example of main.c is shown in Appendix.</p> </li> <li> <p>Create a Makefile in the generated \"src/ui folder\" and execute make command. An example of MakeFile is shown in Appendix.</p> </li> </ol>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#3-deploy-and-run-lvgl-gui-applications","title":"3. Deploy and run LVGL GUI applications","text":"<p>Copy the built executable file into a microSD card so that you can run it on the EVK.</p>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#checking-operation-of-the-application-on-evk","title":"Checking operation of the application on EVK","text":"<ol> <li> <p>Copy the generated executable file to the root filesystem in an SD card. For information about how to copy the file, see Step 7: Deploy sample application.</p> </li> <li> <p>Set execute permission on the file. </p><pre><code>chmod +x &lt;executable file name&gt;\n</code></pre> </li> <li> <p>Execute the file. </p><pre><code>./&lt;executable file name&gt;\n</code></pre> </li> </ol> <p></p>"},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#appendix","title":"Appendix","text":""},{"location":"wiki/lvgl_develop-gui-using-eez-studio/#sample-source-code","title":"Sample source code","text":"main.c<pre><code>#include &lt;unistd.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;limits.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;poll.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;getopt.h&gt;\n\n#include \"lvgl/lvgl.h\"\n#include \"lvgl/lv_drivers/lv_drv_conf.h\"\n\n/* Added to run EEZ Studio generated source code */\n#include \"ui.h\"\n\n#if  USE_FBDEV &amp;&amp; USE_EVDEV\n #undef  RUNS_ON_WAYLAND\n#elif USE_WAYLAND\n #define RUNS_ON_WAYLAND\n#else\n #error  LVGL drivers configuration error.\n#endif\n\n#ifdef RUNS_ON_WAYLAND\n #include \"lvgl/lv_drivers/wayland/wayland.h\"\n#else\n#include \"lvgl/lv_drivers/display/fbdev.h\"\n#include \"lvgl/lv_drivers/indev/evdev.h\"\n\ntypedef struct {\n\tlv_coord_t width;\n\tlv_coord_t height;\n\tbool end;\n\tlv_color_t *buff;\n\tlv_disp_draw_buf_t draw_buf;\n\tlv_disp_drv_t drv;\n\tlv_disp_t *disp;\n\tlv_indev_drv_t indev_drv;\n\tlv_indev_t *mouse_indev;\n} dispinf_fbevdev_t;\n#endif /* RUNS_ON_WAYLAND */\n\n#define\tMAX_JSON_ARR\t8\n#define\tWINDOW_WIDTH\t640\n#define\tWINDOW_HEIGHT\t480\n\n#ifndef RUNS_ON_WAYLAND\n\n/* Create fbdev window with evdev */\nstatic dispinf_fbevdev_t *create_fbdev_window()\n{\n\tuint32_t width, height;\n\tdispinf_fbevdev_t *dispinf;\n\tlv_disp_drv_t *disp_drv;\n\tlv_obj_t *cursor_obj;\n\tbool ret;\n\n\t/* Init Linux frame buffer device for LVGL */\n\tfbdev_init();\n\tfbdev_get_sizes(&amp;width, &amp;height, NULL);\n\n\tdispinf = lv_mem_alloc(sizeof (dispinf_fbevdev_t));\n\tif (!dispinf) {\n\t\tprintf(\"ERROR!! memory allocation failed at lv_mem_alloc()\\n\");\n\t\treturn NULL;\n\t}\n\n\tdispinf-&gt;buff = lv_mem_alloc(width * height * sizeof(lv_color_t));\n\tif (!dispinf-&gt;buff) {\n\t\tprintf(\"ERROR!! memory allocation failed at lv_mem_alloc()\\n\");\n\t\tlv_mem_free(dispinf);\n\t\treturn NULL;\n\t}\n\tlv_disp_draw_buf_init(&amp;dispinf-&gt;draw_buf, dispinf-&gt;buff, NULL,\n\t\t\t\t\t\t\twidth * height);\n\n\tdisp_drv = &amp;dispinf-&gt;drv;\n\t/* Initialize and register a display driver */\n\tlv_disp_drv_init(disp_drv);\n\n\tdisp_drv-&gt;draw_buf   = &amp;dispinf-&gt;draw_buf;\n\tdisp_drv-&gt;flush_cb   = fbdev_flush;\n\tdisp_drv-&gt;hor_res   = (lv_coord_t)width;\n\tdisp_drv-&gt;ver_res   = (lv_coord_t)height;\n\tdisp_drv-&gt;physical_hor_res = (lv_coord_t)width;\n\tdisp_drv-&gt;physical_ver_res = (lv_coord_t)height;\n\n\tdispinf-&gt;disp = lv_disp_drv_register(disp_drv);\n\n\tdispinf-&gt;width = (lv_coord_t)width;\n\tdispinf-&gt;height = (lv_coord_t)height;\n\n\t/* Init evdev for LVGL */\n\tevdev_init();\n\n\tlv_indev_drv_init(&amp;dispinf-&gt;indev_drv);\n\n\tdispinf-&gt;indev_drv.type = LV_INDEV_TYPE_POINTER;\n\t/* This function will be called periodically (by the library)\n\tto get the mouse position and state */\n\tdispinf-&gt;indev_drv.read_cb = evdev_read;\n\n\tdispinf-&gt;mouse_indev = lv_indev_drv_register(&amp;dispinf-&gt;indev_drv);\n\n\t/* Set a cursor for the mouse */\n\tLV_IMG_DECLARE(mouse_cursor);\n\t/* Create an image object for the cursor */\n\tcursor_obj = lv_img_create(lv_scr_act());\n\tlv_img_set_src(cursor_obj, &amp;mouse_cursor);\n\t/* Connect the image object to the driver */\n\tlv_indev_set_cursor(dispinf-&gt;mouse_indev, cursor_obj);\n\n\treturn dispinf;\n}\n\nstatic void close_fbdev_window(dispinf_fbevdev_t *dispinf)\n{\n\tif (!dispinf) {\n\t\tprintf(\"ERROR!! no object to be freed.\\n\");\n\t\treturn;\n\t}\n\n\tif (dispinf-&gt;mouse_indev)\n\t\tlv_indev_delete(dispinf-&gt;mouse_indev);\n\n\tif (dispinf-&gt;disp)\n\t\tlv_disp_remove(dispinf-&gt;disp);\n\n\tif (dispinf-&gt;buff)\n\t\tlv_mem_free(dispinf-&gt;buff);\n\n\tlv_mem_free(dispinf);\n\n\tfbdev_exit();\n}\n#endif\n\nint main(int argc, char *argv[])\n{\n#ifdef RUNS_ON_WAYLAND\n\tstruct pollfd pfd;\n\tuint32_t time_till_next;\n\tint sleep;\n\tlv_disp_t *disp;\n#else /* FBDEV and EVDEV */\n\tdispinf_fbevdev_t *disp;\n#endif\n\tint32_t window_width = WINDOW_WIDTH;\n\tint32_t window_height = WINDOW_HEIGHT;\n\tint32_t ret = 0;\n\n\tint btn_cnt = 0;\n\n\t/*LVGL init*/\n\tlv_init();\n\n#ifdef RUNS_ON_WAYLAND\n\tlv_wayland_init();\n\n\tdisp = lv_wayland_create_window(window_width,window_height,\n\t\t\t\t\t\"Window Demo\", NULL);\n\tif (disp == NULL) {\n\t\tprintf(\"ERROR!! lv_wayland_create_window\\n\");\n\t\tgoto APP_EXIT;\n\t}\n\n\tpfd.fd = lv_wayland_get_fd();\n\tpfd.events = POLLIN;\n\n#else /* FBDEV and EVDEV */\n\tdisp = create_fbdev_window();\n\tif (disp == NULL) {\n\t\tprintf(\"ERROR!! lv_wayland_create_window\\n\");\n\t\tgoto APP_EXIT;\n\t}\n\t/* Clear end flag */\n\tdisp-&gt;end = false;\n\twindow_width = disp-&gt;width;\n\twindow_height = disp-&gt;height;\n#endif\n\n\t/* make_screen */\n\t/*Added to run EEZ Studio generated source code */\n\tui_init();\n\n\twhile(1) {\n#ifdef RUNS_ON_WAYLAND\n\t\t/* Handle any Wayland/LVGL timers/events */\n\t\ttime_till_next = lv_wayland_timer_handler();\n\n\t\t/* Run until the last window closes */\n\t\tif (!lv_wayland_window_is_open(NULL)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Wait for something interesting to happen */\n\t\tif (time_till_next == LV_NO_TIMER_READY) {\n\t\t\tsleep = -1;\n\t\t} else if (time_till_next &gt; INT_MAX) {\n\t\t\tsleep = INT_MAX;\n\t\t} else {\n\t\t\tsleep = time_till_next;\n\t\t}\n\t\twhile ((poll(&amp;pfd, 1, sleep) &lt; 0) &amp;&amp; (errno == EINTR));\n#else /* FBDEV and EVDEV */\n\t\tlv_timer_handler();\n\t\tusleep(5000);\n\t\tif (disp-&gt;end)\n\t\t\tbreak;\n#endif\n\t}\n\nAPP_EXIT:\n\n#ifdef RUNS_ON_WAYLAND\n\tlv_wayland_deinit();\n\n#else /* FBDEV and EVDEV */\n\tclose_fbdev_window(disp);\n#endif\n\treturn 0;\n}\n/**\n* Set in lv_conf.h as `LV_TICK_CUSTOM_SYS_TIME_EXPR`\n*/\nuint32_t custom_tick_get(void)\n{\n\tstatic uint64_t start_ms = 0;\n\tstruct timeval tv_start;\n\tstruct timeval tv_now;\n\tuint64_t now_ms;\n\n\tif(start_ms == 0) {\n\t\tgettimeofday(&amp;tv_start, NULL);\n\t\tstart_ms = (tv_start.tv_sec * 1000000 + tv_start.tv_usec) / 1000;\n\t}\n\tgettimeofday(&amp;tv_now, NULL);\n\tnow_ms = (tv_now.tv_sec * 1000000 + tv_now.tv_usec) / 1000;\n\n\treturn (uint32_t)(now_ms - start_ms);\n}\n</code></pre> Makefile<pre><code>BIN = EEZ_sample\nCFLAGS += -I${SDKTARGETSYSROOT}/usr/include/lvgl -I${SDKTARGETSYSROOT}/usr/include/lvgl/lv_drivers -DLV_CONF_INCLUDE_SIMPLE\nLDFLAGS += -llvgl -llv_drivers -lwayland-client\nSRC_DIR := ./ui\nMAIN := $(SRC_DIR)/main.c\nSRCS := $(shell find $(SRC_DIR) -name '*.c' ! -name 'main.c')\nMAINOBJ = $(MAIN:.c=.o)\nOBJS := $(SRCS:$(SRC_DIR)/%.c=$(SRC_DIR)/%.o)\n.PHONY: all clean\nall: default\n%.o: %.c\n\t@$(CC) $(CFLAGS) -c $&lt; -o $@\ndefault: $(OBJS) $(MAINOBJ)\n\t$(CC) -o $(BIN) $(MAINOBJ) $(OBJS) $(LDFLAGS)\nclean:\n\t@echo \"Cleaning ... \"\n\trm -f $(BIN) $(MAINOBJ) $(OBJS)\n</code></pre>"}]}