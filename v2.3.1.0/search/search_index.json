{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#hmi-sdk-for-rzg-series","title":"HMI SDK for RZ/G Series","text":"<p>The RZ/G HMI Software Development Kit (HMI SDK) is an all-in-one Linux-based development environment for the RZ/G Evaluation Board Kit (EVK).</p> <p>It includes all the software required to build HMI applications quickly and efficiently.</p> <p></p> <p>Easy-to-Use</p> <ul>Provides a simple development environment, making it easier for Linux beginners to work with Linux MPUs.</ul> <p>Free of Charge</p> <ul>All software included in the HMI SDK is available for free.</ul> <p>Ready-to-Use</p> <ul>Includes the following commonly used GUI frameworks and libraries for HMI application development:</ul> <ul> <li>LVGL \u2013 A lightweight, open-source graphics library for embedded systems.</li> <li>Chromium \u2013 A browser-based framework with GPU acceleration for application development.</li> </ul>"},{"location":"#whats-new","title":"What's New","text":"<p>2025/08/07</p> <p>RZ/G HMI SDK version 2.3.1.0 is available.</p> <ul> <li>Update VLP/G from v3.0.6 update3 to v3.0.7.</li> <li>Update RZ MPU HTML5 (Chromium) Package for VLP from v1.0.0 to v1.0.1<ul> <li>Add support for hardware video decoding on Chromium (RZ/G2L only).</li> </ul> </li> <li>Add a video player to home panel demo running on Chromium (RZ/G2L only).</li> <li>Add a sample application program \u2019LVGL home panel demo\u2019.</li> </ul> <p>View Version History &gt;</p>"},{"location":"#how-to-use-this-website","title":"How to Use This Website","text":"<p>This website provides a step-by-step guide from first-time setup to advanced Linux and application development.  You may continue step by step or jump directly to advanced sections. </p> <p></p> <p>Not Sure Where to Start? Here are the recommended flows based on your purpose:</p> <p>\ud83c\udd95 First-time users: Getting Started \u2192 HMI Applications \ud83d\udcbb Developers: Building the HMI SDK with Yocto \u2192 *HMI Applications \u2192 Wiki</p> <p>Before following any flow, we recommend reading Overview first to understand the HMI SDK at a glance. If you have any questions or feedback, please feel free to contact us via FAQ.</p> Getting Started <p>         Start here if this is your first time using the HMI SDK.       </p> <ul> <li>Quick Linux system setup</li> <li>Out-of-box demo applications</li> <li>No build required</li> </ul> <p>         \ud83d\udc49 Next, go to          HMI Applications          to review the details of the demo applications         or challenge yourself by deploying sample applications.       </p> HMI Applications <p>         Explore HMI demo and sample applications.       </p> <ul> <li>Out-of-box demo applications (ready to run)</li> <li>Sample applications that require building and deploying</li> </ul> <p>         \ud83d\udc49 Can be used after          Getting Started          or after         Building the HMI SDK with Yocto.       </p> <p>           \ud83d\udc49 For further development, refer to          Wiki          for creating your own applications.       </p> Building the HMI SDK with Yocto <p>         For developers who need a customized Linux system.       </p> <ul> <li>Custom Linux system build</li> <li>Advanced system configurations</li> <li>Demo applications ready to run</li> <li>Sample applications development can continue</li> </ul> <p>         \ud83d\udc49 Next, go to          HMI Applications          to try the demo and sample applications.       </p> <p>            \ud83d\udc49 Or move on to further development in          Wiki.       </p> Wiki <p>         Advanced development documentation.       </p> <ul> <li>System internals and references</li> <li>Custom application development</li> </ul>"},{"location":"#hmi-frameworks","title":"HMI Frameworks","text":"<p>The HMI SDK supports the following GUI frameworks and libraries for HMI development. It also includes sample applications built with these frameworks and libraries.  For more information about the applications, see Overview.</p>"},{"location":"#lvgl-light-and-versatile-graphics-library","title":"LVGL (Light and Versatile Graphics Library)","text":"<p>LVGL is a free and open-source graphics library that provides everything needed to create an embedded GUI with easy-to-use graphical elements, beautiful visual effects, and a low memory footprint. It is hardware-independent, works with any microcontroller or display, and does not require a GPU, making it ideal for resource-constrained environments.</p> <p> A GUI built with LVGL offers several advantages:</p> <ul> <li>Lightweight and efficient for low-resource devices</li> <li>Highly customizable and flexible</li> <li>No GPU required, reducing hardware costs</li> </ul>"},{"location":"#chromium","title":"Chromium","text":"<p>Chromium is an open-source browser project that aims to build a safer, faster, and more stable way for all Internet users to experience the web. Chromium supports HTML5-based solutions, making it a strong choice for embedded systems requiring modern web technologies. It uses GPU acceleration for rendering, enabling high-performance graphics and smooth user experiences.</p> <p> A browser-based GUI on Chromium (HTML5 solutions) offers several advantages:</p> <ul> <li>Feature-rich user interface</li> <li>Cross-platform compatibility</li> <li>Lower development costs</li> </ul>"},{"location":"#video-tutorials","title":"Video Tutorials","text":"<ul> <li> <p> RZ/G2L Tutorial: Get Started with HMI SDK This video introduces the HMI SDK, shows how to access its website and download the package, and ends with running the demo applications.</p> </li> <li> <p> RZ/G2L Advanced Tutorial: Build the HMI SDK Sample Application This video shows how to build the HMI SDK sample application, then demonstrates how to deploy and run it.</p> </li> </ul>"},{"location":"building_the_hmi_sdk_with_yocto/","title":"Building the HMI SDK with Yocto","text":""},{"location":"building_the_hmi_sdk_with_yocto/#building-the-hmi-sdk-with-yocto","title":"Building the HMI SDK with Yocto","text":""},{"location":"building_the_hmi_sdk_with_yocto/#introduction","title":"Introduction","text":"<p>This page guides you through building the HMI SDK with Yocto. You will be able to modify the source code and customize the Linux environment according to your needs.</p> <p>To build Yocto Linux, the following equipment should be prepared.</p> <p>Equipment</p> <p>Details</p> <p>Linux PC </p> <p>Approximately the following free space is required. - 150 GB for RZ/G2L EVK - 150 GB for RZ/G2LC EVK - 85 GB for RZ/G2UL EVK</p> <p>OS </p> <p>Ubuntu 22.04 LTS, 64-bit version </p> <p>Notice</p> <p>Several updated OSS components, released to address security vulnerabilities and enhance driver performance, are now available on Renesas' GitHub. Please refer to How to Update Linux Packages in the HMI SDK for instructions on how to replace them.</p>"},{"location":"building_the_hmi_sdk_with_yocto/#step-1-obtain-the-rzg-hmi-sdk-yocto-build-package","title":"Step 1: Obtain the RZ/G HMI SDK Yocto Build Package","text":"<p>Please download the HMI SDK Yocto Build Package using the button below. </p> RZ/G2LRZ/G2LCRZ/G2UL <p> HMI SDK Yocto Build Package for RZ/G2L -Yocto Recipes &amp; Pre-built Binary for QSPI Boot</p> <p> HMI SDK Yocto Build Package for RZ/G2LC-Yocto Recipes &amp; Pre-built Binary for QSPI Boot</p> <p> HMI SDK Yocto Build Package for RZ/G2UL-Yocto Recipes &amp; Pre-built Binary for QSPI Boot</p> <p>During the build process, the source code of HMI SDK modules will be downloaded over a network connection. Alternatively, you can also manually download the same source code used to create the HMI SDK binaries and use it offline. Download the HMI SDK Source Code using the button below.</p> <p> Source Codefor all RZ/G devices</p> <p>Notice</p> <ul> <li>The Source Code supplement is very large, so downloading may take some time.</li> <li>Additional setup in Step 2-7 Set up the environment for an offline build is required if you choose to download the source code manually.</li> </ul> <p>Note</p> <p>Refer to File Contents for details about the HMI SDK Yocto Build Package and Source Code. After downloading the package, please review the included Release Note.</p>"},{"location":"building_the_hmi_sdk_with_yocto/#step-2-build-hmi-sdk-with-yocto","title":"Step 2: Build HMI SDK with Yocto","text":"<p>Tip</p> <p>In the following instructions, text shown in angle brackets should be replaced with values specific to your environment.  The angle brackets <code>&lt;</code> and <code>&gt;</code> should not be included when you enter the text.</p> <ol> <li> <p>Install the required packages.</p> <p>Run the following command to install the required packages on your Linux PC.</p> <p></p><pre><code>sudo apt-get update\nsudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping libsdl1.2-dev xterm p7zip-full libyaml-dev libssl-dev bmap-tools\n</code></pre> </li> <li> <p>Set up the <code>git</code> environment.</p> <p>Run the following command to set up the <code>git</code> environment if it has not been configured yet.</p> <p></p><pre><code>git config --global user.email \"&lt;Your email address&gt;\"\ngit config --global user.name \"&lt;Your user name&gt;\"\n</code></pre> <p>Note</p> <p>For more information, refer to Yocto Project Quick Build.</p> </li> <li> <p>Set environment variables.</p> <p>Please set the following environment variables.</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p><pre><code>export WORK=&lt;A directory path for building&gt;\nexport PLATFORM=rzg2l\nexport BOARD=smarc-rzg2l\nexport SDK_PKG_DIR=&lt;A directory path for HMI SDK Yocto Build packages&gt;\n</code></pre> <p></p><pre><code>export WORK=&lt;A directory path for building&gt;\nexport PLATFORM=rzg2l\nexport BOARD=smarc-rzg2lc\nexport SDK_PKG_DIR=&lt;A directory path for HMI SDK Yocto Build Packages&gt;\n</code></pre> <p></p><pre><code>export WORK=&lt;A directory path for building&gt;\nexport PLATFORM=rzg2l\nexport BOARD=smarc-rzg2ul\nexport SDK_PKG_DIR=&lt;Directory path for the HMI SDK Yocto Build Package&gt;\n</code></pre> <p>Tip</p> <p>The <code>SDK_PKG_DIR</code> should point to the directory where you have downloaded your HMI SDK Yocto Build Packages, including <code>RTK0EF0195F*SJ_${PLATFORM}_yocto-and-pre-built-image.zip</code> and <code>RTK0EF0195F*SJ_linux-src.zip</code>.</p> </li> <li> <p>Extract the Yocto recipe package.</p> <p>Decompress the Yocto recipe and pre-built binary image packages.</p> <p></p><pre><code>cd ${SDK_PKG_DIR}\nunzip RTK0EF0195F*SJ_${PLATFORM}_yocto-and-pre-built-image.zip\n</code></pre> <p>Create a working directory.</p> <p></p><pre><code>mkdir -p ${WORK}\n</code></pre> <p>Extract the Yocto recipe package.</p> <p></p><pre><code>cd ${WORK}\ntar xf ${SDK_PKG_DIR}/RTK0EF0195F*SJ_${PLATFORM}_yocto-and-pre-built-image/yocto_recipe_rzg2_hmi-sdk_v*.tar.gz --strip-components 1\n</code></pre> </li> <li> <p>Initialize the build environment.</p> <p>Run the given environment setup script with the command shown below.</p> <p></p><pre><code>cd ${WORK}\nTEMPLATECONF=${PWD}/meta-renesas/meta-${PLATFORM}/docs/template/conf/ source poky/oe-init-build-env build\n</code></pre> </li> <li> <p>Add layers.</p> <p>Add necessary Yocto <code>meta-layers</code> using the following commands.</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p><pre><code>cd ${WORK}/build\nbitbake-layers add-layer ../meta-rz-features/meta-rz-graphics\nbitbake-layers add-layer ../meta-rz-features/meta-rz-codecs\nbitbake-layers add-layer ../meta-clang\nbitbake-layers add-layer ../meta-browser/meta-chromium\nbitbake-layers add-layer ../meta-openembedded/meta-networking\nbitbake-layers add-layer ../meta-browser-hwdecode\nbitbake-layers add-layer ../meta-rz-demos\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nbitbake-layers add-layer ../meta-rz-features/meta-rz-graphics\nbitbake-layers add-layer ../meta-clang\nbitbake-layers add-layer ../meta-browser/meta-chromium\nbitbake-layers add-layer ../meta-openembedded/meta-networking\nbitbake-layers add-layer ../meta-browser-hwdecode\nbitbake-layers add-layer ../meta-rz-demos\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nbitbake-layers add-layer ../meta-rz-demos\n</code></pre> </li> <li> <p>Set up the environment for an offline build.</p> <p>Notice</p> <p>This step configures the environment for offline building when you choose to download the Source Code manually.</p> <p>If you prefer to obtain the source code via the network while building the HMI SDK with Yocto, you can skip this Step 2-7 and continue directly with Step 2-8.</p> <p>Change the environment variable <code>BB_NO_NETWORK</code> in <code>local.conf</code> from <code>0</code>  to <code>1</code> using the <code>sed</code> command.</p> <p></p><pre><code>cd ${WORK}/build\nsed -i \"s|\\(BB_NO_NETWORK =.*\\)\\\"0\\\"|\\1\\\"1\\\"|\" \"conf/local.conf\"\n</code></pre> <p>Decompress the downloaded Source Code and set it up in the build environment.</p> <p></p><pre><code>cd ${SDK_PKG_DIR}\nunzip RTK0EF0195F*SJ_linux-src.zip\ncd ${SDK_PKG_DIR}/RTK0EF0195F*SJ_linux-src/\n7z x oss-souce-code-pkg_rzg2_hmi-sdk_v*.7z\nmv downloads/ ${WORK}/build/\n</code></pre> </li> <li> <p>Modify the configurations for the build environment.</p> <p>Add <code>IMAGE_INSTALL_append</code> and other settings to <code>local.conf</code> using the command shown below.</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p><pre><code>cd ${WORK}/build\nsed -i '$aIMAGE_INSTALL_append = \\\" packagegroup-lvgl-demo packagegroup-benchmark-tools packagegroup-chromium-demo packagegroup-rzg-hmi-sdk-demo \\\"' \"conf/local.conf\"\nsed -i '$aWHITELIST_GPL-3.0 += \\\" glmark2 \\\"' \"conf/local.conf\"\nsed -i '$aPREFERRED_VERSION_nodejs-native = \\\"14.%\\\"' \"conf/local.conf\"\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nsed -i '$aIMAGE_INSTALL_append = \\\" packagegroup-lvgl-demo packagegroup-benchmark-tools packagegroup-chromium-demo packagegroup-rzg-hmi-sdk-demo \\\"' \"conf/local.conf\"\nsed -i '$aWHITELIST_GPL-3.0 += \\\" glmark2 \\\"' \"conf/local.conf\"\nsed -i '$aPREFERRED_VERSION_nodejs-native = \\\"14.%\\\"' \"conf/local.conf\"\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nsed -i '$aIMAGE_INSTALL_append = \\\" packagegroup-lvgl-demo packagegroup-benchmark-tools packagegroup-rzg-hmi-sdk-demo \\\"' \"conf/local.conf\"\n</code></pre> </li> <li> <p>Build images.</p> <p>Run the <code>bitbake</code> command to build the images.</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston\n</code></pre> <p>After completing the build process above, change the eMMC setting from <code>1</code> to <code>0</code>.</p> <p></p><pre><code>cd ${WORK}/build/tmp/work-shared/${BOARD}/kernel-source\nvi arch/arm64/boot/dts/renesas/rzg2l-smarc-som.dtsi\n    (change EMMC setting)\n        before) #define EMMC\t1\n        after)  #define EMMC\t0\n</code></pre> <p>After making the change above, perform the additional build process as follows.</p> <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake linux-renesas -C compile\nMACHINE=${BOARD} bitbake core-image-weston\n</code></pre> <p>Tip</p> <p>The SDK build may fail depending on the build environment. If this happens, try running the build again after some time, or rebuild it from scratch using the commands below. </p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston -c cleanall\nMACHINE=${BOARD} bitbake core-image-weston\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston\n</code></pre> <p>After the above build process, change the setting of SW_SD0_DEV_SEL from <code>1</code> to <code>0</code>. </p><pre><code>cd ${WORK}/build/tmp/work-shared/${BOARD}/kernel-source\nvi arch/arm64/boot/dts/renesas/r9a07g044c2-smarc.dts\n    (change SW_SD0_DEV_SEL setting)\n        before) #define SW_SD0_DEV_SEL 1\n        after)  #define SW_SD0_DEV_SEL 0\n</code></pre> <p>After the change above, perform the additional build process as follows. </p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake linux-renesas -C compile\nMACHINE=${BOARD} bitbake core-image-weston\n</code></pre> <p>Tip</p> <p>The SDK build may fail depending on the build environment. If this happens, try running the build again after some time, or rebuild it from scratch using the commands below. </p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston -c cleanall\nMACHINE=${BOARD} bitbake core-image-weston\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-bsp\n</code></pre> <p>Tip</p> <p>The SDK build may fail depending on the build environment. If this happens, try running the build again after some time, or rebuild it from scratch using the commands below. </p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-bsp -c cleanall\nMACHINE=${BOARD} bitbake core-image-bsp\n</code></pre> <p>Tip</p> <p>The build may take several hours, depending on the PC specifications.  </p> <p>This completes the build of the Linux environment. </p> </li> <li> <p>Create the SDK toolchain.</p> <p>If you want to further deploy sample or your customized applications, building the <code>toolchain</code> is also required. Create the SDK toolchain using the following command.</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston -c populate_sdk\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston -c populate_sdk\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-bsp -c populate_sdk\n</code></pre> </li> </ol> <p>This concludes the Building the HMI SDK with Yocto guide.  </p> <p>Tip</p> <p>Your newly built images and SDK toolchain will be generated in the following directories. Images: <code>${WORK}/build/tmp/deploy/images/${BOARD}/</code> SDK toolchain: <code>${WORK}/build/tmp/deploy/sdk/</code></p> <p>To flash the image to the SD card using bmaptool, refer to Step 4: Create SD Cards with the Prebuilt Image.</p> <p>To boot your device using the prepared SD card, refer to EVK DIP Switch Setup for your boot mode setup.  For detailed information about each demo application, see Demo Applications. For further development of sample applications, see Sample Applications. For additional customizations, see Wiki.</p>"},{"location":"download/","title":"Board and Software","text":""},{"location":"download/#board-and-software","title":"Board and Software","text":"<p>HMI SDK provides the following packages:</p> <ul> <li> <p>HMI SDK Package -eSD Boot Image &amp; Toolchain Installer </p> <p>This package lets you get started right away. You can create a bootable microSD card for the EVK, set up the Linux environment, run the prebuilt demo applications, and build sample HMI applications using the included toolchain installer.   Please go to Getting Started to get started with this HMI SDK Package.</p> <p></p> </li> <li> <p>HMI SDK Yocto Build Package -Yocto Recipes &amp; Pre-built Binary for QSPI Boot</p> <p>This package is for when you want more flexibility. You can build and customize the entire HMI SDK from source. You can also try other boot modes such as QSPI or eMMC, in addition to eSD.    </p> <ul> <li>Source Code -Supplementary for HMI SDK Yocto Build Package         Note that this is optional; the supplementary source code used in the Yocto build is provided for offline builds or as a backup if online fetching fails.</li> </ul> <p> Please go to Building the HMI SDK with Yocto to get started with this HMI SDK Yocto Build Package (and Source Code).        </p> </li> </ul> <p>The packages are designed for specific board models, while the source code is universal and can be used across all boards.</p>"},{"location":"download/#rzg2l-evaluation-board-kit-evk","title":"RZ/G2L Evaluation Board Kit (EVK)","text":"<p> Get RZ/G2L EVK</p> <p> HMI SDK Package for RZ/G2L-eSD Boot Image &amp; Toolchain Installer</p> <p> HMI SDK Yocto Build Package for RZ/G2L-Yocto Recipes &amp; Pre-built Binary for QSPI Boot</p> <p> Source Code-Supplementary for HMI SDK Yocto Build Package</p>"},{"location":"download/#rzg2lc-evaluation-board-kit-evk","title":"RZ/G2LC Evaluation Board Kit (EVK)","text":"<p> Get RZ/G2LC EVK</p> <p> HMI SDK Package for RZ/G2LC-eSD Boot Image &amp; Toolchain Installer</p> <p>HMI SDK Yocto Build Package for RZ/G2LC-Yocto Recipes &amp; Pre-built Binary for QSPI Boot</p> <p> Source Code-Supplementary for HMI SDK Yocto Build Package</p>"},{"location":"download/#rzg2ul-evaluation-board-kit-evk","title":"RZ/G2UL Evaluation Board Kit (EVK)","text":"<p> Get RZ/G2UL EVK</p> <p> HMI SDK Package for RZ/G2UL-eSD Boot Image &amp; Toolchain Installer</p> <p> HMI SDK Yocto Build Package for RZ/G2UL-Yocto Recipes &amp; Pre-built Binary for QSPI Boot</p> <p> Source Code-Supplementary for HMI SDK Yocto Build Package</p> <p>Back to Home &gt; Back to Getting Started &gt;</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#faq","title":"FAQ","text":"<p>If you have any questions about the HMI SDK, please do not hesitate to raise an issue at our Repository Issues.</p> <p>If your questions are common in RZ/G and/or RZ MPU Linux, you may have answers on the following websites.</p> <ul> <li> <p>Renesas \u3088\u304f\u3042\u308b\u3054\u8cea\u554f (FAQ) | Knowledge Base (FAQ's) | \u77e5\u8bc6\u5e93 website</p> <ul> <li>[JP] RZ/G</li> <li>[EN] RZ/G</li> <li>[CN] RZ/G</li> </ul> </li> <li> <p>Renesas Engineering Community website</p> <ul> <li>[JP] RZ MPU</li> <li>[EN] Microprocessors (RZ)</li> <li>[CN] RZ MPU</li> </ul> </li> <li> <p>Renesas Wiki's: RZ/G</p> </li> </ul>"},{"location":"faq/#q-what-is-the-difference-between-vlp-and-hmi-sdk","title":"Q. What is the difference between VLP and HMI SDK?","text":"<p>Please see the figure below.  The left diagram in the figure shows the development method without the HMI SDK. Users need to download and integrate necessary software packages such as VLP (Verified Linux Package), graphics library, codec library, and HMI framework or libraries. The right diagram in the figure shows the development method with the HMI SDK. The HMI SDK is provided as an 'all-in-one package'. Users do NOT need to look for appropriate software and worry about how to integrate all modules.</p> <p>For information about VLP, please visit the website RZ/G Software Package.</p>"},{"location":"faq/#q-what-rules-does-hmi-sdk-version-numbering-follow","title":"Q. What rules does HMI SDK version numbering follow?","text":"<p>The version number of the HMI SDK consists of four numbers.</p> <ul> <li>Version W.X.Y.Z<ul> <li>W = This number is updated when we add new application frameworks or update existing frameworks.</li> <li>X = This number is linked to the major version number of VLP.</li> <li>Y = This number is updated when we make semi-annual VLP updates, add device support, and make minor updates in frameworks. </li> <li>Z = This number is updated when we fix bugs.</li> </ul> </li> </ul> <p>This rule was effective from December 27, 2024.</p>"},{"location":"faq/#q-does-the-chromium-included-in-hmi-sdk-v2300-support-hardware-decoding","title":"Q. Does the Chromium included in HMI SDK v2.3.0.0 support hardware decoding?","text":"<p>The Chromium included in HMI SDK v2.3.0.0 does not support hardware-accelerated video playback using HW codecs.  However, Chromium in HMI SDK v2.3.1.0 is now offering hardware-accelerated video playback. Graphics rendering in Chromium utilizes hardware acceleration. </p>"},{"location":"faq/#q-in-the-chromium-home-panel-demo-the-seek-bar-in-the-video-player-doesnt-seem-to-be-working","title":"Q. In the Chromium Home Panel Demo, the seek bar in the video player doesn't seem to be working.","text":"<p>Please refresh the browser and try again.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#getting-started","title":"Getting Started","text":""},{"location":"getting_started/#introduction","title":"Introduction","text":"<p>This page guides you through getting started with the HMI SDK, including </p> <ul> <li>preparing your environment (Step 1-3)</li> <li>creating SD cards with the prebuilt image (Step 4)</li> <li>running the HMI demo applications (Step 5)</li> </ul>"},{"location":"getting_started/#step-1-obtain-an-rzg-evk","title":"Step 1: Obtain an RZ/G EVK","text":"<p>Click the button below to get the target board.</p> <p>Board and SoftwareGet the board and software for RZ/G series.</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p> <p>RZ/G2L-EVKIT (P/N: RTK9744L23S01000BE)</p> <p>This evaluation board kit is ideal for evaluating RZ/G2L.  The kit includes the following items:</p> <p>Contents</p> <p>Details</p> <p>RZ/G2L Module Board (SMARC2.1)</p> <p>Evaluation board. </p> <p>Common Carrier Board</p> <p>USB Cable (USB Type-A- Micro USB Type-B)</p> <p>For serial communication between the PC and the board.</p> <p></p> <p>RZ/G2LC-EVKIT (P/N: RTK9744C22S01000BE)</p> <p>This evaluation board kit is ideal for evaluating RZ/G2LC.  The kit includes the following items:</p> <p>Contents</p> <p>Details</p> <p>RZ/G2LC Module Board (SMARC2.1)</p> <p>Evaluation board. </p> <p>Common Carrier Board</p> <p>USB Cable (USB Type-A- Micro USB Type-B)</p> <p>For serial communication between the PC and the board.</p> <p></p> <p>RZ/G2UL-EVKIT (P/N: RTK9743U11S01000BE)</p> <p>This evaluation board kit is ideal for evaluating RZ/G2L.  The kit includes the following items:</p> <p>Contents</p> <p>Details</p> <p>RZ/G2UL Module Board (SMARC2.1)</p> <p>Evaluation board. </p> <p>Common Carrier Board</p> <p>USB Cable (USB Type-A- Micro USB Type-B)</p> <p>For serial communication between the PC and the board.</p> <p>Parallel to HDMI Conversion Board</p> <p>For converting the display output from Parallel to HDMI.</p>"},{"location":"getting_started/#step-2-prepare-the-necessary-equipment","title":"Step 2: Prepare the Necessary Equipment","text":"<p>Please prepare the following required equipment.</p> <p>Tip</p> <ul> <li>For details on the required equipment, refer to Necessary Equipment. </li> <li>For instructions on how to set up the equipment with your EVK board, refer to EVK Peripheral Setup. </li> </ul> <p>RZ/G EVK </p> <ul> <li>Target board (Module Board &amp; Common Carrier Board)  </li> <li>USB Cable (to connect the board and PC via serial)  </li> <li>*Parallel to HDMI Conversion Board (to convert the FFC/FPC connector to a micro HDMI connector, only for RZ/G2UL)</li> </ul> <p>For Creating SD Cards with the Prebuilt Image </p> <ul> <li>USB Power PD AC Adapter &amp; USB Type-C PD Cable (to power the board)</li> <li>PC (Windows or Linux OS)</li> <li>Micro SD Card &amp; Reader (minimum 4GB, 8GB or larger recommended)</li> </ul> <p>For Running the HMI Demo Applications </p> <ul> <li>HDMI Display &amp; HDMI Cable (to display the demo applications)</li> <li>USB Hub (to connect multiple USB devices)</li> <li>USB Keyboard &amp; Mouse (to operate the demo applications)</li> <li>*USB Camera (for video input, for RZ/G2L and RZ/G2LC)</li> <li>Audio Speaker (for audio output)</li> </ul>"},{"location":"getting_started/#step-3-obtain-the-rzg-hmi-sdk-package","title":"Step 3: Obtain the RZ/G HMI SDK Package","text":"<p>Please download from the HMI SDK Package using the button below. </p> RZ/G2LRZ/G2LCRZ/G2UL <p> HMI SDK Package for RZ/G2L-eSD Boot Image &amp; Toolchain Installer</p> <p> HMI SDK Package for RZ/G2LC-eSD Boot Image &amp; Toolchain Installer</p> <p> HMI SDK Package for RZ/G2UL-eSD Boot Image &amp; Toolchain Installer</p> <p>Note</p> <p>Refer to File Contents for details about the HMI SDK Package. After downloading the package, please review the included Release Note.</p>"},{"location":"getting_started/#step-4-create-sd-cards-with-the-prebuilt-image","title":"Step 4: Create SD Cards with the Prebuilt Image","text":"RZ/G2LRZ/G2LCRZ/G2UL <p>After downloading the HMI SDK Package, locate the image file.</p> <p>Target Board</p> <p>Image File</p> <p>Location</p> <p>RZ/G2L</p> <p>core-image-weston-smarc-rzg2l.wic.gz</p> <p>image-file_rzg2l_hmi-sdk_v2.3.1.0.zip</p> <p>After downloading the HMI SDK Package, locate the image file.</p> <p>Target Board</p> <p>Image File</p> <p>Location</p> <p>RZ/G2L</p> <p>core-image-weston-smarc-rzg2lc.wic.gz</p> <p>image-file_rzg2lc_hmi-sdk_v2.3.1.0.zip</p> <p>After downloading the HMI SDK Package, locate the image file.</p> <p>Target Board</p> <p>Image File</p> <p>Location</p> <p>RZ/G2UL</p> <p>core-image-bsp-smarc-rzg2ul.wic.gz</p> <p>image-file_rzg2ul_hmi-sdk_v2.3.1.0.zip</p>"},{"location":"getting_started/#option-1-for-windows-pc","title":"Option 1. For Windows PC","text":"<ol> <li>Download or copy the HMI SDK package to your PC.</li> <li> <p>Unzip the package and extract the image file.</p> <p>i. Right-click the downloaded package <code>RTK0EF0195F02310SJ_rzg2l.zip</code> \u2192 Extract All... ii. Open the folder and right-click <code>image-file_rzg2l_hmi-sdk_v2.3.1.0.zip</code> \u2192 Extract All... iii. Inside, you will find the image file: <code>core-image-weston-smarc-rzg2l.wic.gz</code></p> </li> <li> <p>Flash the image file <code>core-image-weston-smarc-rzg2l.wic.gz</code> to your micro SD card using one of the following tools:</p> <ul> <li>Win32 Disk Imager</li> <li>balenaEtcher</li> </ul> <p>Caution</p> <p>Even if you see a message such as <code>you need to format the disk</code> before/after flashing the image, do not format the SD card.</p> </li> </ol>"},{"location":"getting_started/#option-2-for-linux-pc-ubuntu","title":"Option 2. For Linux PC (Ubuntu)","text":"<ol> <li> <p>Install the required packages and software.</p> <p>i. Run the following command to install the required packages.</p> <p></p><pre><code>sudo apt-get update\nsudo apt-get install unzip bmap-tools\n</code></pre> <p>ii. Run the following command to set up the <code>git</code> environment if it has not been configured yet.</p> <p>Tip</p> <p>This step is required only if you plan to continue with further development, such as building sample applications. If you only want to complete Step 5: Run the HMI Demo Applications, you may skip this step.</p> <p></p><pre><code>git config --global user.email \"&lt;Your email address&gt;\"\ngit config --global user.name \"&lt;Your user name&gt;\"\n</code></pre> <p>Note</p> <p>For more information, refer to Yocto Project Quick Build.</p> </li> <li> <p>Download or copy the HMI SDK package to your PC.</p> </li> <li> <p>Unzip the package and extract the image file.</p> <p>Tip</p> <p>If you are using the GUI of Linux Ubuntu, please refer to the similar steps described in the Option 1. For Windows PC -2.</p> <p>i. Unzip the HMI SDK package.</p> <p>Navigate to the directory where the HMI SDK package was installed.</p> <p></p><pre><code>unzip RTK0EF0195F02310SJ_rzg2l.zip\ncd RTK0EF0195F02310SJ_rzg2l/\n</code></pre> <p>ii. Unzip the image file folder.</p> <p></p><pre><code>unzip image-file_rzg2l_hmi-sdk_v2.3.1.0.zip\ncd image-file_rzg2l_hmi-sdk_v2.3.1.0/\n</code></pre> <p>iii. Locate the target image file <code>core-image-weston-smarc-rzg2l.wic.gz</code>.</p> <p></p><pre><code>ls\n</code></pre> <pre><code>core-image-weston-smarc-rzg2l.wic.gz \ncore-image-weston-smarc-rzg2l.wic.bmap \ncore-image-weston-smarc-rzg2l.manifest\n</code></pre> <p>Notice</p> <ul> <li>No need to decompress <code>core-image-weston-smarc-rzg2l.wic.gz</code> manually.</li> <li>Ensure that the image file <code>core-image-weston-smarc-rzg2l.wic.gz</code> is located in the same directory as <code>core-image-weston-smarc-rzg2l.wic.bmap</code> to flash the image to the SD card successfully.</li> </ul> </li> <li> <p>Insert the micro SD card into your Linux PC and identify its device name and mount points.</p> <p>Use the <code>lsblk</code> command to check the <code>&lt;device name&gt;</code> and <code>&lt;mount point&gt;</code> as follows:</p> <ul> <li> <p>Before inserting the SD card:</p> <p></p><pre><code>lsblk\n</code></pre> <pre><code>NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\n    (snip)\nnvme0n1     259:0    0 465.8G  0 disk\n\u251c\u2500nvme0n1p1 259:1    0   512M  0 part /boot/efi\n\u2514\u2500nvme0n1p2 259:2    0 465.3G  0 part /\n</code></pre> <ul> <li>After inserting the SD card:</li> </ul> <p></p><pre><code>lsblk\n</code></pre> <pre><code>NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\n    (snip)\nnvme0n1     259:0    0 465.8G  0 disk\n\u251c\u2500nvme0n1p1 259:1    0   512M  0 part /boot/efi\n\u2514\u2500nvme0n1p2 259:2    0 465.3G  0 part /\nsda           8:0    1  14.5G  0 disk\n\u251c\u2500sda1        8:1    1   500M  0 part /media/user/boot\n\u2514\u2500sda2        8:2    1   3.4G  0 part /media/user/rootfs\n</code></pre> </li> </ul> <p>Tip</p> <p>The device name is assigned to the SD card by Linux on your Host PC. It typically appears as <code>/dev/sdx</code>, where <code>x</code> is a letter representing the physical drive. In this example, the SD card\u2019s device name is <code>/dev/sda</code>, and its mount points are <code>/media/user/boot</code> and <code>/media/user/rootfs</code></p> </li> <li> <p>Unmount the SD card if it is currently mounted.</p> <p>Use the <code>umount</code> command with the mount points. </p> <p></p><pre><code>umount &lt;mount point&gt;\n</code></pre> <p>In this example:</p> <p></p><pre><code>umount /media/user/boot\numount /media/user/rootfs\n</code></pre> </li> <li> <p>Flash the image to the SD card using <code>bmaptool</code>.</p> <p>Use the <code>bmaptool</code> command with the device name of SD card. </p> <p>Caution</p> <p>Before running <code>bmaptool</code>, double-check the <code>&lt;device name&gt;</code>. Make sure the target device (your SD card) is correct and not your system disk. Using the wrong device will overwrite all data on that disk and may render your system unbootable.</p> <p>Caution</p> <p>The operation below will erase the contents of your SD card.        </p> <p></p><pre><code>sudo bmaptool copy core-image-weston-smarc-rzg2l.wic.gz &lt;device name&gt;\n</code></pre> <p>In this example:</p> <p></p><pre><code>sudo bmaptool copy core-image-weston-smarc-rzg2l.wic.gz /dev/sda\n</code></pre> </li> </ol>"},{"location":"getting_started/#option-1-for-windows-pc_1","title":"Option 1. For Windows PC","text":"<ol> <li>Download or copy the HMI SDK package to your PC.</li> <li> <p>Unzip the package and extract the image file.</p> <p>i. Right-click the downloaded package <code>RTK0EF0195F02310SJ_rzg2lc.zip</code> \u2192 Extract All... ii. Open the folder and right-click <code>image-file_rzg2lc_hmi-sdk_v2.3.1.0.zip</code> \u2192 Extract All... iii. Inside, you will find the image file: <code>core-image-weston-smarc-rzg2lc.wic.gz</code></p> </li> <li> <p>Flash the image file <code>core-image-weston-smarc-rzg2lc.wic.gz</code> to your micro SD card using one of the following tools:</p> <ul> <li>Win32 Disk Imager</li> <li>balenaEtcher</li> </ul> <p>Caution</p> <p>Even if you see a message such as <code>you need to format the disk</code> before/after flashing the image, do not format the SD card.</p> </li> </ol>"},{"location":"getting_started/#option-2-for-linux-pc-ubuntu_1","title":"Option 2. For Linux PC (Ubuntu)","text":"<ol> <li> <p>Install the required packages and software.</p> <p>i. Run the following command to install the required packages.</p> <p></p><pre><code>sudo apt-get update\nsudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat cpio python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping libsdl1.2-dev xterm p7zip-full libyaml-dev libssl-dev bmap-tools\n</code></pre> <p>ii. Run the following command to set up the <code>git</code> environment if it has not been configured yet.</p> <p>Tip</p> <p>This step is required only if you plan to continue with further development, such as building sample applications. If you only want to complete Step 5: Run the HMI Demo Applications, you may skip this step.</p> <p></p><pre><code>git config --global user.email \"&lt;Your email address&gt;\"\ngit config --global user.name \"&lt;Your user name&gt;\"\n</code></pre> <p>Note</p> <p>For more information, refer to Yocto Project Quick Build.</p> </li> <li> <p>Download or copy the HMI SDK package to your PC.</p> </li> <li> <p>Unzip the package and extract the image file.</p> <p>Tip</p> <p>If you are using the GUI of Linux Ubuntu, please refer to the similar steps described in the Option 1. For Windows PC -2.</p> <p>i. Unzip the HMI SDK package.</p> <p>Navigate to the directory where the HMI SDK package was installed.</p> <p></p><pre><code>unzip RTK0EF0195F02310SJ_rzg2lc.zip\ncd RTK0EF0195F02310SJ_rzg2lc/\n</code></pre> <p>ii. Unzip the image file folder.</p> <p></p><pre><code>unzip image-file_rzg2lc_hmi-sdk_v2.3.1.0.zip\ncd image-file_rzg2lc_hmi-sdk_v2.3.1.0/\n</code></pre> <p>iii. Locate the target image file <code>core-image-weston-smarc-rzg2lc.wic.gz</code>.</p> <p></p><pre><code>ls\n</code></pre> <pre><code>core-image-weston-smarc-rzg2lc.wic.gz \ncore-image-weston-smarc-rzg2lc.wic.bmap \ncore-image-weston-smarc-rzg2lc.manifest\n</code></pre> <p>Notice</p> <ul> <li>No need to decompress <code>core-image-weston-smarc-rzg2lc.wic.gz</code> manually.</li> <li>Ensure that the image file <code>core-image-weston-smarc-rzg2lc.wic.gz</code> is located in the same directory as <code>core-image-weston-smarc-rzg2lc.wic.bmap</code> to flash the image to the SD card successfully.</li> </ul> </li> <li> <p>Insert the micro SD card into your Linux PC and identify its device name and mount points.</p> <p>Use the <code>lsblk</code> command to check the <code>&lt;device name&gt;</code> and <code>&lt;mount point&gt;</code> as follows:</p> <ul> <li> <p>Before inserting the SD card:</p> <p></p><pre><code>lsblk\n</code></pre> <pre><code>NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\n    (snip)\nnvme0n1     259:0    0 465.8G  0 disk\n\u251c\u2500nvme0n1p1 259:1    0   512M  0 part /boot/efi\n\u2514\u2500nvme0n1p2 259:2    0 465.3G  0 part /\n</code></pre> <ul> <li>After inserting the SD card:</li> </ul> <p></p><pre><code>lsblk\n</code></pre> <pre><code>NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\n    (snip)\nnvme0n1     259:0    0 465.8G  0 disk\n\u251c\u2500nvme0n1p1 259:1    0   512M  0 part /boot/efi\n\u2514\u2500nvme0n1p2 259:2    0 465.3G  0 part /\nsda           8:0    1  14.5G  0 disk\n\u251c\u2500sda1        8:1    1   500M  0 part /media/user/boot\n\u2514\u2500sda2        8:2    1   3.4G  0 part /media/user/rootfs\n</code></pre> </li> </ul> <p>Tip</p> <p>The device name is assigned to the SD card by Linux on your Host PC. It typically appears as <code>/dev/sdx</code>, where <code>x</code> is a letter representing the physical drive. In this example, the SD card\u2019s device name is <code>/dev/sda</code>, and its mount points are <code>/media/user/boot</code> and <code>/media/user/rootfs</code></p> </li> <li> <p>Unmount the SD card if it is currently mounted.</p> <p>Use the <code>umount</code> command with the mount points. </p> <p></p><pre><code>umount &lt;mount point&gt;\n</code></pre> <p>In this example:</p> <p></p><pre><code>umount /media/user/boot\numount /media/user/rootfs\n</code></pre> </li> <li> <p>Flash the image to the SD card using <code>bmaptool</code>.</p> <p>Use the <code>bmaptool</code> command with the device name of SD card. </p> <p>Caution</p> <p>Before running <code>bmaptool</code>, double-check the <code>&lt;device name&gt;</code>. Make sure the target device (your SD card) is correct and not your system disk. Using the wrong device will overwrite all data on that disk and may render your system unbootable.</p> <p>Caution</p> <p>The operation below will earse the contents of your SD card.         </p> <p></p><pre><code>sudo bmaptool copy core-image-weston-smarc-rzg2lc.wic.gz &lt;device name&gt;\n</code></pre> <p>In this example:</p> <p></p><pre><code>sudo bmaptool core-image-weston-smarc-rzg2lc.wic.gz /dev/sda\n</code></pre> </li> </ol>"},{"location":"getting_started/#option-1-for-windows-pc_2","title":"Option 1. For Windows PC","text":"<ol> <li>Download or copy the HMI SDK package to your PC.</li> <li> <p>Unzip the package and extract the image file.</p> <p>i. Right-click the downloaded package <code>RTK0EF0195F02310SJ_rzg2ul.zip</code> \u2192 Extract All... ii. Open the folder and right-click <code>image-file_rzg2ul_hmi-sdk_v2.3.1.0.zip</code> \u2192 Extract All... iii. Inside, you will find the image file: <code>core-image-bsp-smarc-rzg2ul.wic.gz</code></p> </li> <li> <p>Flash the image file <code>core-image-bsp-smarc-rzg2ul.wic.gz</code> to your micro SD card using one of the following tools:</p> <ul> <li>Win32 Disk Imager</li> <li>balenaEtcher</li> </ul> <p>Caution</p> <p>Even if you see a message such as <code>you need to format the disk</code> before/after flashing the image, do not format the SD card.</p> </li> </ol>"},{"location":"getting_started/#option-2-for-linux-pc-ubuntu_2","title":"Option 2. For Linux PC (Ubuntu)","text":"<ol> <li> <p>Install the required packages and software.</p> <p>i. Run the following command to install the required packages.</p> <p></p><pre><code>sudo apt-get update\nsudo apt-get install unzip bmap-tools\n</code></pre> <p>ii. Run the following command to set up the <code>git</code> environment if it has not been configured yet.</p> <p>Tip</p> <p>This step is required only if you plan to continue with further development, such as building sample applications. If you only want to complete Step 5: Run the HMI Demo Applications, you may skip this step.</p> <p></p><pre><code>git config --global user.email \"&lt;Your email address&gt;\"\ngit config --global user.name \"&lt;Your user name&gt;\"\n</code></pre> </li> <li> <p>Download or copy the HMI SDK package to your PC.</p> </li> <li> <p>Unzip the package and extract the image file.</p> <p>Tip</p> <p>If you are using the GUI of Linux Ubuntu, please refer to the similar steps described in the Option 1. For Windows PC -2.</p> <p>i. Unzip the HMI SDK package.</p> <p>Navigate to the directory where the HMI SDK package was installed.</p> <p></p><pre><code>unzip RTK0EF0195F02310SJ_rzg2ul.zip\ncd RTK0EF0195F02310SJ_rzg2ul/\n</code></pre> <p>ii. Unzip the image file folder.</p> <p></p><pre><code>unzip image-file_rzg2ul_hmi-sdk_v2.3.1.0.zip\ncd image-file_rzg2ul_hmi-sdk_v2.3.1.0/\n</code></pre> <p>iii. Locate the target image file <code>core-image-bsp-smarc-rzg2ul.wic.gz</code>.</p> <p></p><pre><code>ls\n</code></pre> <pre><code>core-image-bsp-smarc-rzg2ul.wic.gz \ncore-image-bsp-smarc-rzg2ul.wic.bmap \ncore-image-bsp-smarc-rzg2ul.manifest\n</code></pre> <p>Notice</p> <ul> <li>No need to decompress <code>core-image-bsp-smarc-rzg2ul.wic.gz</code> manually.</li> <li>Ensure that the image file <code>core-image-bsp-smarc-rzg2ul.wic.gz</code> is located in the same directory as <code>core-image-bsp-smarc-rzg2ul.wic.bmap</code> to flash the image to the SD card successfully.</li> </ul> </li> <li> <p>Insert the micro SD card into your Linux PC and identify its device name and mount points.</p> <p>Use the <code>lsblk</code> command to check the <code>&lt;device name&gt;</code> and <code>&lt;mount point&gt;</code> as follows:</p> <ul> <li> <p>Before inserting the SD card:</p> <p></p><pre><code>lsblk\n</code></pre> <pre><code>NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\n    (snip)\nnvme0n1     259:0    0 465.8G  0 disk\n\u251c\u2500nvme0n1p1 259:1    0   512M  0 part /boot/efi\n\u2514\u2500nvme0n1p2 259:2    0 465.3G  0 part /\n</code></pre> <ul> <li>After inserting the SD card:</li> </ul> <p></p><pre><code>lsblk\n</code></pre> <pre><code>NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT\n    (snip)\nnvme0n1     259:0    0 465.8G  0 disk\n\u251c\u2500nvme0n1p1 259:1    0   512M  0 part /boot/efi\n\u2514\u2500nvme0n1p2 259:2    0 465.3G  0 part /\nsda           8:0    1  14.5G  0 disk\n\u251c\u2500sda1        8:1    1   500M  0 part /media/user/boot\n\u2514\u2500sda2        8:2    1   3.4G  0 part /media/user/rootfs\n</code></pre> </li> </ul> <p>Tip</p> <p>The device name is assigned to the SD card by Linux on your Host PC. It typically appears as <code>/dev/sdx</code>, where <code>x</code> is a letter representing the physical drive. In this example, the SD card\u2019s device name is <code>/dev/sda</code>, and its mount points are <code>/media/user/boot</code> and <code>/media/user/rootfs</code></p> </li> <li> <p>Unmount the SD card if it is currently mounted.</p> <p>Use the <code>umount</code> command with the mount points. </p> <p></p><pre><code>umount &lt;mount point&gt;\n</code></pre> <p>In this example:</p> <p></p><pre><code>umount /media/user/boot\numount /media/user/rootfs\n</code></pre> </li> <li> <p>Flash the image to the SD card using <code>bmaptool</code>.</p> <p>Use the <code>bmaptool</code> command with the device name of SD card.</p> <p>Caution</p> <p>Before running <code>bmaptool</code>, double-check the <code>&lt;device name&gt;</code>. Make sure the target device (your SD card) is correct and not your system disk. Using the wrong device will overwrite all data on that disk and may render your system unbootable.</p> <p>Caution</p> <p>The operation below will earse the contents of your SD card. </p> <p></p><pre><code>sudo bmaptool copy core-image-bsp-smarc-rzg2ul.wic.gz &lt;device name&gt;\n</code></pre> <p>In this example:</p> <p></p><pre><code>sudo bmaptool core-image-bsp-smarc-rzg2ul.wic.gz /dev/sda\n</code></pre> </li> </ol>"},{"location":"getting_started/#step-5-run-the-hmi-demo-applications","title":"Step 5: Run the HMI Demo Applications","text":"<p>The HMI SDK supports the following demo applications. Follow the steps below to use them.</p> <ul> <li>LVGL Benchmark Demo</li> <li>LVGL Home Panel Demo</li> <li>Chromium Home Panel Demo</li> </ul> <p> Follow the steps below to use them.</p> <ol> <li> <p>Prepare the necessary equipment and connect it to your EVK board by following the instructions in Hardware Setup.</p> </li> <li> <p>Set up the DIP switch for eSD boot mode.</p> RZ/G2LRZ/G2LCRZ/G2UL <p>Set up DIP switch SW1 and SW11 as follows.</p> <ul> <li> <p>SW1</p> <p></p> SW1-1 SW1-2 ON ON </li> <li> <p>SW11</p> <p></p> SW11-1 SW11-2 SW11-3 SW11-4 ON ON OFF ON </li> </ul> <p>Set up DIP switch SW1 and SW11 as follows.</p> <ul> <li> <p>SW1</p> <p></p> SW1-1 SW1-2 SW1-3 SW1-4 SW1-5 SW1-6 ON ON ON* OFF* ON* Not used <p>*These switches are not related to the settings required for this boot mode.</p> </li> <li> <p>SW11</p> <p></p> SW11-1 SW11-2 SW11-3 SW11-4 ON ON OFF ON </li> </ul> <p>Set up DIP switch SW1 and SW11 as follows.</p> <ul> <li> <p>SW1</p> <p></p> SW1-1 SW1-2 SW1-3 ON ON ON* <p>*This switch is not related to the settings required for this boot mode.</p> </li> <li> <p>SW11</p> <p></p> SW11-1 SW11-2 SW11-3 SW11-4 ON ON OFF ON </li> </ul> </li> <li> <p>Insert the bootable microSD card created in Step 4 into the microSD card slot for eSD boot mode (sd ChC CN3 port on Module Board), and then power on the EVK board.</p> <p>Tip</p> <ul> <li>Please refer to the EVK Peripheral Setup for the location of the microSD card slot.</li> <li>Press and hold the power button (red button, SW9) for 1 second to turn on the EVK board, and for 2 seconds to turn it off.</li> </ul> </li> <li> <p>The HMI SDK Demo Launcher launches automatically once the device is fully booted. </p> <p>Right after boot, you will see the launch window as shown below.</p> <p> </p> <p>After a few seconds, the HMI SDK Demo Launcher will appear. Click the corresponding button to try each demo application we provide.</p> <p></p> </li> </ol> <p>This concludes the Getting Started guide.  For detailed information about each demo application, see Demo Applications. For further development of sample applications, see Sample Applications. For additional customizations, see Wiki.</p>"},{"location":"history/","title":"Version","text":""},{"location":"history/#version","title":"Version","text":""},{"location":"history/#rzg-hmi-sdk-v2310","title":"RZ/G HMI SDK v2.3.1.0","text":"<p>2025/08/07</p> <p>RZ/G HMI SDK version 2.3.1.0 is available.</p> <ul> <li>Update VLP/G from v3.0.6 update3 to v3.0.7.</li> <li>Update RZ MPU HTML5 (Chromium) Package for VLP from v1.0.0 to v1.0.1<ul> <li>Add support for hardware video decoding on Chromium (RZ/G2L only).</li> </ul> </li> <li>Add a video player to home panel demo running on Chromium (RZ/G2L only).</li> <li>Add a sample application program \u2019LVGL home panel demo\u2019.</li> </ul>"},{"location":"history/#rzg-hmi-sdk-v2300","title":"RZ/G HMI SDK v2.3.0.0","text":"<p>2024/12/27</p> <p>RZ/G HMI SDK version 2.3.0.0 is available.</p> <ul> <li>Add Chromium (except for RZ/G2UL)</li> <li>Update VLP/G from v3.0.6 update2 to v3.0.6 update3.</li> <li>Add support for RZ/G2LC Evaluation Board Kit and RZ/G2UL Evaluation Board Kit.</li> <li>Add sample application programs, home panel demo (RZ/G2L only) and demo launcher.</li> </ul>"},{"location":"history/#rzg-hmi-sdk-v100","title":"RZ/G HMI SDK v1.00","text":"<p>2024/07/31</p> <p>RZ/G HMI SDK v1.00 is available.</p> <p>Back to Home &gt;</p>"},{"location":"hmi_applications/","title":"HMI Applications","text":""},{"location":"hmi_applications/#hmi-applications","title":"HMI Applications","text":"<p>There are several ways to explore running HMI applications using the HMI SDK on RZ/G EVK boards.</p> <p>This page will guide you through:</p> <ul> <li>Trying the out-of-box Demo Applications</li> <li>Building and deploying Sample Applications</li> </ul> <p> After completing these, you can also develop your own HMI applications by referring to the instructions provided in Wiki.</p>"},{"location":"hmi_applications/#hardware-setup","title":"Hardware Setup","text":""},{"location":"hmi_applications/#necessary-equipment","title":"Necessary Equipment","text":"<ul> <li>Please prepare the following required equipment.</li> </ul> <p>Equipment</p> <p>Requirements</p> <p>Included with RZ/G EVK </p> <p>Target RZ/G EVK Board </p> <p>USB Cable (for serial communication) </p> <p>Port: Connect to micro USB Type-B (2.0) port on the board </p> <p>*Parallel to HDMI Conversion Board </p> <p>*Only for RZ/G2UL  Used to convert an FFC/FPC connector to a micro HDMI connector.</p> <p>USB Power Delivery (PD) AC Adapter &amp; USB Type-C PD Cable</p> <p>Port: Connect to the USB Type-C port on the board </p> <p>PC </p> <p>Storage: 100GB or more free space on HDD/SSD Memory: 8GB or more RAM CPU: 4-core or more CPU OS: Linux: Ubuntu 22.04 LTS, 64-bit version Windows: Windows 10 or 11</p> <p>Micro SD Card &amp; Reader </p> <p>Type: SDHC Speed Class: UHI-Class 10 Capacity: Minimum 4GB, recommended 8GB  A micro SD card is used to store the Linux system and prebuilt demo images from the HMI SDK.</p> <p>HDMI Display &amp; HDMI Cable </p> <p>Port: Connect to the micro HDMI on the board  For touch displays, both HDMI and USB cables are required. Standard: USB HID Compliant  No specific resolution is required. The board automatically uses the resolutions supported by your HDMI display. See How to Change the Display Resolution for more information.</p> <p>USB Hub </p> <p>Used when multiple USB devices are needed. </p> <p>USB Keyboard </p> <p>Standard: USB HID Compliant </p> <p>USB Mouse </p> <p>Standard: USB HID Compliant </p> <p>*USB Camera </p> <p>Only for RZ/G2L and RZ/G2LC. Standard*: USB HID Compliant</p> <p>Audio Speaker </p> <p>Port: 3.5mm mini plug connector </p> <p>*Ethernet Cable </p> <p>Used to connect the board to your host PC or network.  *Optional, only needed when developing using methods such as:   File transfer (binaries, logs, images)   SSH access (remote login)   Network access (internet or communication with other devices)</p> <p>Tip</p> <p>A Windows PC can be used for flashing an SD card and debugging via a serial connection.  For further development and deployment, use a Linux PC.</p>"},{"location":"hmi_applications/#evk-peripheral-setup","title":"EVK Peripheral Setup","text":"<p>Please set up the necessary equipment referring to the EVK peripheral diagram below.</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p> <p></p> <p></p> <p>Tip</p> <ul> <li>For eSD boot mode, insert the microSD card into the sd ChC slot (CN3) on the module board; for QSPI boot mode, insert the microSD card into the micro SD slot (CN10) on the common carrier board.</li> <li>If you use a touch-panel HDMI display, in addition to the HDMI cable, a USB cable connected to USB 1 (CN12) is required to enable touch functionality.</li> <li>For Ethernet connection, RZ/G2L and RZ/G2UL support Ethernet 0 (CN9) and Ethernet 1 (CN8), while RZ/G2LC supports only Ethernet 0 (CN9).</li> </ul>"},{"location":"hmi_applications/#evk-dip-switch-setup","title":"EVK DIP Switch Setup","text":"<ul> <li>eSD Boot Mode</li> </ul> RZ/G2LRZ/G2LCRZ/G2UL <p>Set DIP switch SW1 and SW11 as follows.</p> <ul> <li> <p>SW1 (on Module Board)</p> <p></p> SW1-1 SW1-2 ON ON </li> <li> <p>SW11 (on Common Carrier Board)</p> <p></p> SW11-1 SW11-2 SW11-3 SW11-4 ON ON OFF ON </li> </ul> <p>Set DIP switch SW1 and SW11 as follows.</p> <ul> <li> <p>SW1 (on Module Board)</p> <p></p> SW1-1 SW1-2 SW1-3 SW1-4 SW1-5 SW1-6 ON ON ON* OFF* ON* Not used <p>*These switches are not related to the settings required for this boot mode.</p> </li> <li> <p>SW11 (on Common Carrier Board)</p> <p></p> SW11-1 SW11-2 SW11-3 SW11-4 ON ON OFF ON </li> </ul> <p>Set DIP switch SW1 and SW11 as follows.</p> <ul> <li> <p>SW1 (on Module Board)</p> <p></p> SW1-1 SW1-2 SW1-3 ON ON ON* <p>*This switch is not related to the settings required for this boot mode.</p> </li> <li> <p>SW11 (on Common Carrier Board)</p> <p></p> SW11-1 SW11-2 SW11-3 SW11-4 ON ON OFF ON </li> </ul> <ul> <li>QSPI Boot Mode</li> </ul> <p>Set DIP switch SW11 as follows for all boards.</p> <p></p> SW11-1 SW11-2 SW11-3 SW11-4 OFF OFF OFF ON <p>Notice</p> <p>Firmware (bootloader) updates are required for QSPI boot modes. Please follow the steps provided in How to Update Firmware (Flash Writer and Bootloaders).</p> <p>Note</p> <p>Please refer to How to Boot from a microSD Card in QSPI Boot Mode for details.</p>"},{"location":"hmi_applications/#demo-applications","title":"Demo Applications","text":"<p>This section explains how to run the HMI demo applications and provides detailed introductions for each one.</p> <p>The HMI SDK Demo Launcher starts automatically when the EVK boots. Currently, it includes the following prebuilt demo applications. If you want to customize them, their source code can be downloaded from the GitHub links listed in the table below.</p> <p>Type</p> <p>Demo Applications</p> <p>Target Device</p> <p>Source Code URL</p> <p>LVGL </p> <p>LVGL Benchmark Demo</p> <p>RZ/G2L, RZ/G2LC, RZ/G2UL</p> <p>Link to GitHub</p> <p>LVGL Home Panel Demo</p> <p>RZ/G2L, RZ/G2LC, RZ/G2UL</p> <p>Link to GitHub</p> <p>Chromium</p> <p>Chromium Home Panel Demo</p> <p>RZ/G2L, RZ/G2LC</p> <p>Link to GitHub</p> <p> Please follow the steps below to run the demo applications.</p> <ol> <li> <p>Prepare the necessary equipment and configure the EVK DIP switches by following the instructions in Hardware Setup.</p> </li> <li> <p>Insert the bootable microSD card into the microSD card slot for eSD boot mode (sd ChC CN3 port on Module Board), and then power on the EVK board.</p> <p>Tip</p> <ul> <li>Please refer to the EVK Peripheral Setup for the location of the microSD card slot.</li> <li>Press and hold the power button (red button, SW9) for 1 second to turn on the EVK board, and for 2 seconds to turn it off.</li> </ul> </li> <li> <p>The HMI SDK Demo Launcher launches automatically once the device is fully booted. </p> <p>Right after boot, you will see the launch window as shown below.</p> <p> </p> <p>After a few seconds, the HMI SDK Demo Launcher will appear. Click the corresponding button to try each demo application we provide.</p> <p></p> <p>Tip</p> <p>If you want to exit a demo application and return to the HMI SDK Demo Launcher, you can either  *  restart your EVK board by press reset button (blue button, SW10) or  *  run the following command in your board terminal to relaunch it:  </p><pre><code>/usr/share/demo-launcher/start_demo.sh \n</code></pre> <p>Note that this is temporary behavior, and we will improve it in future releases.</p> <p></p> <ul> <li>LVGL Demo Applications</li> </ul> LVGL Benchmark DemoLVGL Home Panel Demo <p>This demo application is implemented using LVGL, and it includes the following tools for performance testing.</p> <p></p> <p>Please click each tool and follow the detailed instructions to try them. After you finish trying the tools, click the Quit button at the top-right corner to exit.</p> <p></p> <p>This demo application is implemented using LVGL.  Click the buttons or use the sidebar to explore the available functions.</p> <p> </p> <p>For example, by clicking the Image Gallery button, you will see the screen shown below.</p> <p></p> <p>For example, by clicking the Home Automation button, you will see the screen shown below.</p> <p></p> <p></p> <ul> <li>Chromium Demo Applications</li> </ul> Chromium Home Panel Demo <p>This demo application is implemented using Chromium, and it presents an HTML5 single-page home panel interface. Click the buttons or use the sidebar to explore the available functions.</p> <p></p> <p>For example, by clicking the Video Player button, you will see the screen shown below.</p> <p></p> <p>Tip</p> <p>Please refresh the browser before using the seek bar in the Video Player.        </p> <p>For example, by clicking the Home Automation button, you will see the screen shown below.</p> <p></p> <p>For RZ/G2L and RZ/G2LC, the live camera function is also available.The image below is captured using USB Camera. Please switch the camera display mode using the control on top.</p> <p></p> </li> </ol>"},{"location":"hmi_applications/#sample-applications","title":"Sample Applications","text":"<p>This section explains how to build, deploy, and run the HMI sample applications, as well as provides detailed introductions for each one.</p> <p>We have prepared the following sample applications.  Their source code can be downloaded from the GitHub links listed in the table below.</p> <p>Type</p> <p>Sample Applications</p> <p>Target Device</p> <p>Source Code URL</p> <p>LVGL </p> <p>LVGL Sample Program for Image Display</p> <p>RZ/G2L, RZ/G2LC, RZ/G2UL</p> <p>Link to GitHub</p> <p>LVGL Sample Program for Audio Playback</p> <p>RZ/G2L, RZ/G2LC</p> <p>Link to GitHub</p> <p>LVGL Sample Program for Video Playback</p> <p>RZ/G2L</p> <p>Link to GitHub</p> <p>The executable binaries are also available in the <code>bin</code> directory of each sample application, so you can run the samples without building them yourself. If you choose to use the binaries, simply download them, skip Step 1, and start from Step 2: Deploy Sample Applications.</p>"},{"location":"hmi_applications/#step-1-build-sample-applications","title":"Step 1: Build Sample Applications","text":"<p>Tip</p> <p>This step requires a Linux PC (Ubuntu).</p> <ol> <li> <p>Install cross-compilation toolchain.</p> <ul> <li> <p>When Using the HMI SDK Package</p> <p>If you download the HMI SDK Package and follow the Getting Started setup instructions, you will find the toolchain installer script included in the package. Follow the steps below to install the toolchain for your board. </p> RZ/G2LRZ/G2LCRZ/G2UL <p>Target Board</p> <p>Toolchain Installer Script</p> <p>Location</p> <p>RZ/G2L</p> <p>poky-glibc-x86_64-core-image-weston-aarch64-smarc-rzg2l-toolchain-3.1.33.sh</p> <p>toolchain-installer_rzg2l_hmi-sdk_v2.3.1.0.zip</p> <p>Unzip the package, and extract the installer.</p> <p>Navigate to the directory where the HMI SDK Package was extracted.</p> <p></p><pre><code>cd RTK0EF0195F02310SJ_rzg2l/\nunzip toolchain-installer_rzg2l_hmi-sdk_v2.3.1.0.zip\n</code></pre> <p>Then, install the toolchain.</p> <p></p><pre><code>cd toolchain-installer_rzg2l_hmi-sdk_v2.3.1.0/\nsudo sh poky-glibc-x86_64-core-image-weston-aarch64-smarc-rzg2l-toolchain-3.1.33.sh\n</code></pre> <p>Target Board</p> <p>Toolchain Installer Script</p> <p>Location</p> <p>RZ/G2LC</p> <p>poky-glibc-x86_64-core-image-weston-aarch64-smarc-rzg2lc-toolchain-3.1.33.sh</p> <p>toolchain-installer_rzg2lc_hmi-sdk_v2.3.1.0.zip</p> <p>Unzip the package, and extract the installer.</p> <p>Navigate to the directory where the HMI SDK Package was extracted.</p> <p></p><pre><code>cd RTK0EF0195F02310SJ_rzg2lc/\nunzip toolchain-installer_rzg2lc_hmi-sdk_v2.3.1.0.zip\n</code></pre> <p>Then, install the toolchain.</p> <p></p><pre><code>cd toolchain-installer_rzg2lc_hmi-sdk_v2.3.1.0/\nsudo sh poky-glibc-x86_64-core-image-weston-aarch64-smarc-rzg2lc-toolchain-3.1.33.sh\n</code></pre> <p>Target Board</p> <p>Toolchain Installer Script</p> <p>Location</p> <p>RZ/G2UL</p> <p>poky-glibc-x86_64-core-image-bsp-aarch64-smarc-rzg2ul-toolchain-3.1.33.sh</p> <p>toolchain-installer_rzg2ul_hmi-sdk_v2.3.1.0.zip</p> <p>Unzip the package, and extract the installer.</p> <p>Navigate to the directory where the HMI SDK Package was extracted.</p> <p></p><pre><code>cd RTK0EF0195F02310SJ_rzg2ul/\nunzip toolchain-installer_rzg2ul_hmi-sdk_v2.3.1.0.zip\n</code></pre> <p>Then, install the toolchain as follows:</p> <p></p><pre><code>cd toolchain-installer_rzg2ul_hmi-sdk_v2.3.1.0/\nsudo sh poky-glibc-x86_64-core-image-bsp-aarch64-smarc-rzg2ul-toolchain-3.1.33.sh\n</code></pre> <p>Tip</p> <p>Please set the directory for installing the toolchain.</p> <p>The default <code>&lt;path-to-toolchain&gt;</code> is <code>/opt/poky/3.1.33</code>, which is used in the instructions below. If you set the target directory manually, please remember to update the path accordingly in the next step.</p> <p></p> </li> <li> <p>When Using the HMI SDK Yocto Build Package</p> <p>If you download the HMI SDK Yocto Build Package, please ensure that you have completed Step 2-10: Create the SDK toolchain in Building the HMI SDK with Yocto. Then follow the steps below to install the toolchain for your board.</p> <p>Tip</p> <p><code>${WORK}</code> refers to the directory you set in Step 2-3. Set environment variables in Building the HMI SDK with Yocto.</p> RZ/G2LRZ/G2LCRZ/G2UL <p>Target Board</p> <p>Toolchain Installer Script</p> <p>Location</p> <p>RZ/G2L</p> <p>poky-glibc-x86_64-core-image-weston-aarch64-smarc-rzg2l-toolchain-3.1.33.sh</p> <p>${WORK}/build/tmp/deploy/sdk/</p> <p>Install the toolchain.</p> <p></p><pre><code>cd ${WORK}/build/tmp/deploy/sdk/\nsudo sh poky-glibc-x86_64-core-image-weston-aarch64-smarc-rzg2l-toolchain-3.1.33.sh\n</code></pre> <p>Target Board</p> <p>Toolchain Installer Script</p> <p>Location</p> <p>RZ/G2LC</p> <p>poky-glibc-x86_64-core-image-weston-aarch64-smarc-rzg2lc-toolchain-3.1.33.sh</p> <p>${WORK}/build/tmp/deploy/sdk/</p> <p>Install the toolchain.</p> <p></p><pre><code>cd ${WORK}/build/tmp/deploy/sdk/\nsudo sh poky-glibc-x86_64-core-image-weston-aarch64-smarc-rzg2lc-toolchain-3.1.33.sh\n</code></pre> <p>Target Board</p> <p>Toolchain Installer Script</p> <p>Location</p> <p>RZ/G2UL</p> <p>poky-glibc-x86_64-core-image-bsp-aarch64-smarc-rzg2ul-toolchain-3.1.33.sh</p> <p>${WORK}/build/tmp/deploy/sdk/</p> <p>Install the toolchain.</p> <p></p><pre><code>cd ${WORK}/build/tmp/deploy/sdk/\nsudo sh poky-glibc-x86_64-core-image-bsp-aarch64-smarc-rzg2ul-toolchain-3.1.33.sh\n</code></pre> <p>Tip</p> <p>Please set the directory for installing the toolchain.</p> <p>The default <code>&lt;path-to-toolchain&gt;</code> is <code>/opt/poky/3.1.33</code>, which is used in the instructions below. If you set the target directory manually, please remember to update the path accordingly in the next step.</p> </li> </ul> </li> <li> <p>Enable cross compiler.</p> <p></p><pre><code>source &lt;path-to-toolchain&gt;/environment-setup-aarch64-poky-linux\n</code></pre> <p>By default:</p> <p></p><pre><code>source /opt/poky/3.1.33/environment-setup-aarch64-poky-linux\n</code></pre> </li> <li> <p>Get the sample application source code.</p> <p>Navigate to the directory where you want to store the source code.</p> <p></p><pre><code>git clone https://github.com/renesas-rz/rzg_hmi_sdk\n</code></pre> </li> <li> <p>Go to the source code working directory.</p> <p></p><pre><code>cd &lt;path-to&gt;/rzg_hmi_sdk/sample_app/&lt;sample-application-directory&gt;\n</code></pre> <p>Tip</p> <p>Existing <code>&lt;sample-application-directory&gt;</code>entries are listed in the table below.</p> <code>&lt;sample-application-directory&gt;</code> Description <code>lvgl/lvgl_sample_img_disp</code> LVGL Sample Application for Image Display <code>lvgl/lvgl_sample_audio_playback</code> LVGL Sample Application for Audio Playback <code>lvgl/lvgl_sample_video_playback</code> LVGL Sample Application for Video Playback </li> <li> <p>Build sample applications.</p> <p></p><pre><code>make\n</code></pre> <p>The executable binaries for the sample applications are built as follows: <code>rzg_hmi_sdk/sample_app/&lt;sample-application-directory&gt;/&lt;sample-application-binary&gt;</code>.</p> <p>Tip</p> <p>The executable binaries file name (<code>&lt;sample-application-binary&gt;</code>) is the same as its directory name.</p> <p>For example, for <code>lvgl_sample_img_disp</code>, the path to the built executable is: </p><pre><code>&lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_img_disp/lvgl_sample_img_disp\n</code></pre> </li> </ol>"},{"location":"hmi_applications/#step-2-deploy-sample-applications","title":"Step 2: Deploy Sample Applications","text":"<p>Tip</p> <ul> <li>This step requires a Linux PC (Ubuntu).</li> <li>For operations that require entering commands on the EVK board, you can use the on-screen terminal at the top-left corner of the display, or connect remotely using an terminal emulator such as Tera Term.</li> </ul>"},{"location":"hmi_applications/#option-1-over-ethernet-using-scp","title":"Option 1. Over Ethernet (using <code>SCP</code>)","text":"<ol> <li> <p>Connect the EVK board to your Linux PC and boot it.</p> <p>Connect an Ethernet cable between the EVK\u2019s RJ45 port and your Linux PC.</p> <p>Note</p> <p>Refer to EVK Peripheral Setup for details.</p> RZ/G2LRZ/G2LCRZ/G2UL <p>RJ45 ports Ethernet 0 (CN9) and Ethernet 1 (CN8) are available; either port can be used.</p> <p>RJ45 ports is Ethernet 0 (CN9).</p> <p>RJ45 ports Ethernet 0 (CN9) and Ethernet 1 (CN8) are available; either port can be used.</p> <p>Press and hold the power button (red button, SW9) for 1 second to turn on the EVK board. </p> </li> <li> <p>Check your EVK board\u2019s IP address.</p> <p>Run the <code>ip</code> command on your EVK board as follows.</p> <p></p><pre><code>ip a\n</code></pre> <p>Tip</p> <p>For example, if the RZ/G2L board is connected to the local network through the CN8 Ethernet port:</p> <pre><code>root@smarc-rzg2l:~# ip a | grep eth\n5: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,DYNAMIC,UP&gt; mtu 1500 qdisc mq state DOWN group default qlen 1000\n    link/ether f2:d6:18:24:f0:6b brd ff:ff:ff:ff:ff:ff\n6: eth1: &lt;BROADCAST,MULTICAST,DYNAMIC,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000\n    link/ether 72:26:f0:8b:64:59 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.0.32/24 brd 192.168.0.255 scope global dynamic eth1\n</code></pre> <p>RZ/G2L board's IP address is <code>192.168.0.32</code> (at <code>eth1</code>).</p> </li> <li> <p>Copy the executable binary files and resource files to your EVK board (external SD card storage).</p> <p>Copy the executable binary files from your Linux PC (Ubuntu) using <code>scp</code> command.</p> LVGL Sample Application for Image DisplayLVGL Sample Application for Audio PlaybackLVGL Sample Application for Video Playback <p></p><pre><code>scp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_img_disp/lvgl_sample_img_disp root@&lt;your-EVK-IP&gt;:/home/root/\n</code></pre> <p></p><pre><code>scp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_audio_playback/lvgl_sample_audio_playback root@&lt;your-EVK-IP&gt;:/home/root/\n</code></pre> <p></p><pre><code>scp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_video_playback/lvgl_sample_video_playback root@&lt;your-EVK-IP&gt;:/home/root/\n</code></pre> <p>Tip</p> <ul> <li>We recommend copying the file to the <code>/home/root</code> directory.</li> <li>Don\u2019t forget to replace <code>&lt;your-EVK-IP&gt;</code> with your EVK's IP address.</li> </ul> <p> Copy resource files from your Linux PC (Ubuntu) using <code>scp</code> command.</p> LVGL Sample Application for Image DisplayLVGL Sample Application for Audio PlaybackLVGL Sample Application for Video Playback <p>Notice</p> <p>Please make sure the <code>/usr/share/images/</code> exists on your EVK before using scp. If it does not exist, create it using the following command: </p><pre><code>mkdir /usr/share/images/\n</code></pre> <p></p><pre><code>scp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_img_disp/sample/* root@&lt;your-EVK-IP&gt;:/usr/share/images/\n</code></pre> <p>Notice</p> <p>Please make sure the <code>/usr/share/sounds/sample/</code> exists on your EVK board before using scp. If it does not exist, create it using the following command: </p><pre><code>mkdir /usr/share/sounds/sample/\n</code></pre> <p></p><pre><code>scp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_audio_playback/sample/* root@&lt;your-EVK-IP&gt;:/usr/share/sounds/sample/\n</code></pre> <p>Notice</p> <p>Please make sure the <code>/usr/share/movies/</code> exists on your EVK board before using scp. If it does not exist, create it using the following command: </p><pre><code>mkdir /usr/share/movies/\n</code></pre> <p></p><pre><code>scp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_video_playback/sample/* root@&lt;your-EVK-IP&gt;:/usr/share/movies/\n</code></pre> <p>Tip</p> <p>Don\u2019t forget to replace <code>&lt;your-EVK-IP&gt;</code> with your EVK's IP address.</p> </li> </ol>"},{"location":"hmi_applications/#option-2-over-sd-card","title":"Option 2. Over SD Card","text":"<ol> <li> <p>Insert your SD card into the Linux PC and mount it.</p> <p>Notice</p> <p>Make sure to turn off your EVK board before ejecting the SD card. Press and hold the power button for 2 seconds to turn it off.</p> </li> <li> <p>Copy the executable binary files and resource files to your SD card.</p> <p>Tip</p> <p>Follow the instructions in Step 4 in Option 2 to check where your SD card is mounted using the <code>lsblk</code> command.</p> <p>For example, if the SD card is mounted at <code>/media/user/rootfs</code>.</p> <p>Copy the executable binary files.</p> LVGL Sample Application for Image DisplayLVGL Sample Application for Audio PlaybackLVGL Sample Application for Video Playback <p></p><pre><code>cp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_img_disp/lvgl_sample_img_disp /media/user/rootfs/home/root/\n</code></pre> <p></p><pre><code>cp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_audio_playback/lvgl_sample_audio_playback /media/user/rootfs/home/root/\n</code></pre> <p></p><pre><code>cp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_video_playback/lvgl_sample_video_playback /media/user/rootfs/home/root/\n</code></pre> <p>Tip</p> <p>We recommend copying the file to the <code>/home/root</code> directory.</p> <p> Copy resource files.</p> LVGL Sample Application for Image DisplayLVGL Sample Application for Audio PlaybackLVGL Sample Application for Video Playback <p>Notice</p> <p>Please make sure the <code>/usr/share/images/</code> exists on your SD card before copying. If it does not exist, create it using the following command: </p><pre><code>mkdir /media/user/rootfs/usr/share/images/\n</code></pre> <p></p><pre><code>cp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_img_disp/sample/* /media/user/rootfs/usr/share/images/\n</code></pre> <p>Notice</p> <p>Please make sure the <code>/usr/share/sounds/sample/</code> exists on your SD card before using scp. If it does not exist, create it using the following command: </p><pre><code>mkdir /media/user/rootfs/usr/share/sounds/sample/\n</code></pre> <p></p><pre><code>cp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_audio_playback/sample/* /media/user/rootfs/usr/share/sounds/sample/\n</code></pre> <p>Notice</p> <p>Please make sure the <code>/usr/share/movies/</code> exists on your SD card before using scp. If it does not exist, create it using the following command: </p><pre><code>mkdir /media/user/rootfs/usr/share/movies/\n</code></pre> <p></p><pre><code>cp &lt;path-to&gt;/rzg_hmi_sdk/sample_app/lvgl/lvgl_sample_video_playback/sample/* /media/user/rootfs/usr/share/movies/\n</code></pre> </li> </ol>"},{"location":"hmi_applications/#step-3-run-the-hmi-sample-applications","title":"Step 3: Run the HMI Sample Applications","text":"<ol> <li> <p>Prepare the necessary equipment and configure the EVK DIP switches by following the instructions in Hardware Setup.</p> </li> <li> <p>Insert the bootable microSD card created in Step 2 into the microSD card slot, and then power on the EVK board.</p> <p>Tip</p> <ul> <li>Please refer to the EVK Peripheral Setup to locate the microSD card slot based on your selected boot mode.</li> <li>Press and hold the power button (red button, SW9) for 1 second to turn on the EVK board, and for 2 seconds to turn it off.</li> </ul> </li> <li> <p>Set execute permission and run the sample applications on your EVK board. </p> <ul> <li>LVGL Sample Applications</li> </ul> LVGL Sample Application for Image DisplayLVGL Sample Application for Audio PlaybackLVGL Sample Application for Video Playback <p>Grant execute permission to the binary files.</p> <p></p><pre><code>cd /home/root\n</code></pre> <p></p><pre><code>chmod +x lvgl_sample_img_disp\n</code></pre> <p>Run the executable binary files.</p> <p></p><pre><code>./lvgl_sample_img_disp\n</code></pre> <p>The launched sample application is shown below. This sample application is implemented using LVGL and can display image files in BMP, JPG, PNG, and GIF formats.</p> <p> </p> <p>Click the button to display the image from the source file.</p> <p> </p> <p>To exit, simply close the window or press Ctrl+C in the EVK board terminal.</p> <p>Grant execute permission to the binary files.</p> <p></p><pre><code>cd /home/root\n</code></pre> <p></p><pre><code>chmod +x lvgl_sample_audio_playback\n</code></pre> <p>Run the executable binary files.</p> <p></p><pre><code>./lvgl_sample_audio_playback\n</code></pre> <p>The launched sample application is shown below. This sample application is implemented using LVGL and can play audio files in mp3, AAC, and WAV formats.</p> <p></p> <p>Click the button to start, stop, or pause the audio from the source file.</p> <p>To exit, simply close the window or press Ctrl+C in the EVK board terminal.</p> <p>Grant execute permission to the binary files.</p> <p></p><pre><code>cd /home/root\n</code></pre> <p></p><pre><code>chmod +x lvgl_sample_video_playback\n</code></pre> <p>Run the executable binary files.</p> <p></p><pre><code>./lvgl_sample_video_playback\n</code></pre> <p>The launched sample application is shown below. This sample application is implemented using LVGL, and it can play movie files in MP4 format.</p> <p> </p> <p>Click the button to start, stop, or pause the video from the source file.</p> <p> </p> <p>To exit, simply close the window or press Ctrl+C in the EVK board terminal.</p> </li> </ol>"},{"location":"hmi_frameworks/_components/__front_matter/","title":"front matter","text":""},{"location":"hmi_frameworks/_components/__front_matter/#hmi-frameworks","title":"HMI Frameworks","text":"<p>The HMI SDK supports the following GUI frameworks and libraries for HMI development. It also includes sample applications built with these frameworks and libraries.  For more information about the applications, see Overview.</p>"},{"location":"hmi_frameworks/_components/__front_matter/#lvgl-light-and-versatile-graphics-library","title":"LVGL (Light and Versatile Graphics Library)","text":"<p>LVGL is a free and open-source graphics library that provides everything needed to create an embedded GUI with easy-to-use graphical elements, beautiful visual effects, and a low memory footprint. It is hardware-independent, works with any microcontroller or display, and does not require a GPU, making it ideal for resource-constrained environments.</p> <p> A GUI built with LVGL offers several advantages:</p> <ul> <li>Lightweight and efficient for low-resource devices</li> <li>Highly customizable and flexible</li> <li>No GPU required, reducing hardware costs</li> </ul>"},{"location":"hmi_frameworks/_components/__front_matter/#chromium","title":"Chromium","text":"<p>Chromium is an open-source browser project that aims to build a safer, faster, and more stable way for all Internet users to experience the web. Chromium supports HTML5-based solutions, making it a strong choice for embedded systems requiring modern web technologies. It uses GPU acceleration for rendering, enabling high-performance graphics and smooth user experiences.</p> <p> A browser-based GUI on Chromium (HTML5 solutions) offers several advantages:</p> <ul> <li>Feature-rich user interface</li> <li>Cross-platform compatibility</li> <li>Lower development costs</li> </ul>"},{"location":"how_to_use_this%20_website/_components/__front_matter/","title":"front matter","text":""},{"location":"how_to_use_this%20_website/_components/__front_matter/#how-to-use-this-website","title":"How to Use This Website","text":"<p>This website provides a step-by-step guide from first-time setup to advanced Linux and application development.  You may continue step by step or jump directly to advanced sections. </p> <p></p> <p>Not Sure Where to Start? Here are the recommended flows based on your purpose:</p> <p>\ud83c\udd95 First-time users: Getting Started \u2192 HMI Applications \ud83d\udcbb Developers: Building the HMI SDK with Yocto \u2192 *HMI Applications \u2192 Wiki</p> <p>Before following any flow, we recommend reading Overview first to understand the HMI SDK at a glance. If you have any questions or feedback, please feel free to contact us via FAQ.</p> Getting Started <p>         Start here if this is your first time using the HMI SDK.       </p> <ul> <li>Quick Linux system setup</li> <li>Out-of-box demo applications</li> <li>No build required</li> </ul> <p>         \ud83d\udc49 Next, go to          HMI Applications          to review the details of the demo applications         or challenge yourself by deploying sample applications.       </p> HMI Applications <p>         Explore HMI demo and sample applications.       </p> <ul> <li>Out-of-box demo applications (ready to run)</li> <li>Sample applications that require building and deploying</li> </ul> <p>         \ud83d\udc49 Can be used after          Getting Started          or after         Building the HMI SDK with Yocto.       </p> <p>           \ud83d\udc49 For further development, refer to          Wiki          for creating your own applications.       </p> Building the HMI SDK with Yocto <p>         For developers who need a customized Linux system.       </p> <ul> <li>Custom Linux system build</li> <li>Advanced system configurations</li> <li>Demo applications ready to run</li> <li>Sample applications development can continue</li> </ul> <p>         \ud83d\udc49 Next, go to          HMI Applications          to try the demo and sample applications.       </p> <p>            \ud83d\udc49 Or move on to further development in          Wiki.       </p> Wiki <p>         Advanced development documentation.       </p> <ul> <li>System internals and references</li> <li>Custom application development</li> </ul>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#overview","title":"Overview","text":"<p>The HMI SDK provides a Yocto-based Linux environment with development tools, system libraries, graphics and multimedia support, and HMI frameworks such as HTML5 or LVGL, making it easy to create and run HMI applications.</p> <p>The HMI SDK is specifically designed for the supported RZ/G EVKs and includes fixed Linux components. The source is also provided for further development and customization. </p> <p>For an easy setup and quick access to the out-of-the-box demo applications, please refer to Getting Started. For a customized Linux environment\u2014such as modifying the memory map or adding support for your own board, please refer to Building the HMI SDK with Yocto.</p>"},{"location":"overview/#supported-boards","title":"Supported Boards","text":"<ul> <li>RZ/G2L  Evaluation Board Kit (RTK9744L23S01000BE)</li> <li>RZ/G2LC Evaluation Board Kit (RTK9744C22S01000BE)</li> <li>RZ/G2UL Evaluation Board Kit (RTK9743U11S01000BE)</li> </ul>"},{"location":"overview/#sdk-components","title":"SDK Components","text":"<p>HMI SDK provides the following packages:</p> <ul> <li> <p>HMI SDK Package -eSD Boot Image &amp; Toolchain Installer </p> <p>This package lets you get started right away. You can create a bootable microSD card for the EVK, set up the Linux environment, run the prebuilt demo applications, and build sample HMI applications using the included toolchain installer.   Please go to Getting Started to get started with this HMI SDK Package.</p> <p></p> </li> <li> <p>HMI SDK Yocto Build Package -Yocto Recipes &amp; Pre-built Binary for QSPI Boot</p> <p>This package is for when you want more flexibility. You can build and customize the entire HMI SDK from source. You can also try other boot modes such as QSPI or eMMC, in addition to eSD.    </p> <ul> <li>Source Code -Supplementary for HMI SDK Yocto Build Package         Note that this is optional; the supplementary source code used in the Yocto build is provided for offline builds or as a backup if online fetching fails.</li> </ul> <p> Please go to Building the HMI SDK with Yocto to get started with this HMI SDK Yocto Build Package (and Source Code).        </p> </li> </ul> <p>The packages are designed for specific board models, while the source code is universal and can be used across all boards.</p>"},{"location":"overview/#file-contents","title":"File Contents","text":"<p>The contents of the packages are as follows:</p> <p>Packages</p> <p>Content File</p> <p>Details</p> <p>HMI SDK Package -eSD Boot Image &amp; Toolchain Installer (RTK0EF0195F02310SJ_&lt;dev&gt;) </p> <p>image-file_&lt;dev&gt;_hmi-sdk_v2.3.1.0.zip</p> <p>Bootable SD card images in WIC format</p> <p>licenses_rzg2_hmi-sdk_v2.3.1.0.zip</p> <p>License files for open-source software used in HMI SDK</p> <p>r01an7976ej0100-rzg-hmi-sdk.pdf</p> <p>Release notes with RZ/G HMI SDK information</p> <p>README.txt</p> <p>README with package details</p> <p>toolchain-installer_&lt;dev&gt;_hmi-sdk_v2.3.1.0.zip</p> <p>Cross-toolchain installer for building sample applications</p> <p>HMI SDK Yocto Build Package -Yocto Recipes &amp; Pre-built Binary for QSPI Boot (RTK0EF0195F02310SJ_&lt;dev&gt;_yocto-and-pre-built-image) </p> <p>licenses_rzg2_hmi-sdk_v2.3.1.0.zip</p> <p>License files for open-source components used in HMI SDK</p> <p>pre-built-binary_&lt;dev&gt;_hmi-sdk_v2.3.1.0.zip</p> <p>Pre-built binaries (bootloader, Linux kernel, root filesystem, flash writer) for SPI boot mode</p> <p>r01an7976ej0100-rzg-hmi-sdk.pdf</p> <p>Release notes with RZ/G HMI SDK information</p> <p>README.txt</p> <p>README with package details</p> <p>yocto_recipe_rzg2_hmi-sdk_v2.3.1.0.tar.gz</p> <p>Yocto meta layers for building HMI SDK</p> <p>Tip</p> <p>&lt;dev&gt; in the table represents a device name, such as rzg2l for RZ/G2L, rzg2lc RZ/G2LC, or rzg2ul for RZ/G2UL. The angle brackets <code>&lt;</code> and <code>&gt;</code> should not be included when you enter the text.</p> <p>The contents of the source code are as follows:</p> <p>Supplements</p> <p>Content File</p> <p>Details</p> <p>Source Code -Supplementary for HMI SDK Yocto Build Package (RTK0EF0195F02310SJ_linux-src) </p> <p>licenses_rzg2_hmi-sdk_v2.3.1.0.zip</p> <p>License files for open-source components used in HMI SDK</p> <p>oss-souce-code-pkg_rzg2_hmi-sdk_v2.3.1.0.7z</p> <p>Source code package of open-source components for building HMI SDK</p> <p>r01an7976ej0100-rzg-hmi-sdk.pdf</p> <p>Release notes with RZ/G HMI SDK information</p> <p>README.txt</p> <p>README with package details</p>"},{"location":"overview/#hmi-application-contents","title":"HMI Application Contents","text":"<p>HMI Demo Applications</p> <p>When the HMI SDK Linux system boots, the Demo Application Launcher starts automatically. The pre-installed demo applications can then be launched from the Demo Application Launcher\u2014for example, the Chromium Home Panel Demo shown below.  </p> <p>Follow the instructions under Demo Applications in the HMI Applications section to view these demos. They come as pre-built binaries, with source code also provided in the table below:</p> <p>Type</p> <p>Demo Applications</p> <p>Target Device</p> <p>Source Code URL</p> <p>LVGL </p> <p>LVGL Benchmark Demo</p> <p>RZ/G2L, RZ/G2LC, RZ/G2UL</p> <p>Link to GitHub</p> <p>LVGL Home Panel Demo</p> <p>RZ/G2L, RZ/G2LC, RZ/G2UL</p> <p>Link to GitHub</p> <p>Chromium</p> <p>Chromium Home Panel Demo</p> <p>RZ/G2L, RZ/G2LC</p> <p>Link to GitHub</p> <p>HMI Sample Applications</p> <p>The sample applications are not pre-built and require additional building and deployment. Follow the instructions under Sample Applications in the HMI Applications section to try them, with source code also provided in the table below:</p> <p>Type</p> <p>Sample Applications</p> <p>Target Device</p> <p>Source Code URL</p> <p>LVGL </p> <p>LVGL Sample Program for Image Display</p> <p>RZ/G2L, RZ/G2LC, RZ/G2UL</p> <p>Link to GitHub</p> <p>LVGL Sample Program for Audio Playback</p> <p>RZ/G2L, RZ/G2LC</p> <p>Link to GitHub</p> <p>LVGL Sample Program for Video Playback</p> <p>RZ/G2L</p> <p>Link to GitHub</p>"},{"location":"overview/#specification","title":"Specification","text":"<p>RZ/G HMI SDK includes the following software modules:</p> <ul> <li>RZ/G Verified Linux Package Version 3.0.7</li> <li>RZ MPU Graphics Library V3.1.2.3 for RZ/G2L and RZ/G2LC</li> <li>RZ MPU Video Codec Library V3.1.3.0 for RZ/G2L</li> </ul> <p>Note</p> <p>Please refer to RZ/G Verified Linux Package (5.10-CIP) for more details on the software modules.</p> <p>Notice</p> <p>Several updated OSS components, released to address security vulnerabilities and enhance driver performance, are now available on Renesas' GitHub. Please refer to How to Update Linux Packages in the HMI SDK in Wiki for instructions on how to replace them.</p>"},{"location":"overview/#component-information","title":"Component Information","text":"<p>For detailed component information, please refer to the table below:</p> Components Version Details Linux Kernel 5.10.229-cip54 SLTS (Super Long Term Support) kernel Yocto 3.1.31 (dunfell) Distribution for embedded Linux GCC 8.3.0 (Arm GCC 8.3-2019.03) Compiler glibc 2.28 busybox 1.30.1 OpenSSL 1.1.1n GStreamer 1.0 1.16.3 GStreamer UM for RZ/G2LGStreamer Sample Applications Wayland 1.18.0 Weston 8.0.0 Python 3.8.18 LVGL 8.3.11 lv-drivers 8.3.0 FiraCode 6.2 Tomlc99 *<sup>1</sup> OpenCL OpenCL Overview OpenGL ES OpenGL ES Overview OpenMAX IL 1.1 OpenMAX IL Overview <ol> <li>Commit ID 5221b3d. \u21a9</li> </ol> <p></p>"},{"location":"wiki/","title":"Wiki","text":""},{"location":"wiki/#wiki","title":"Wiki","text":"<p>This page contains information and tips related to the RZ/G HMI SDK.</p>"},{"location":"wiki/#common","title":"Common","text":"<ul> <li>How to Change the Display Resolution</li> <li>How to Update Firmware (Flash Writer and Bootloaders)</li> <li>How to Boot from a microSD Card in QSPI Boot Mode</li> <li>How to Update Linux Packages in the HMI SDK</li> <li>How to Debug an Application with GDB</li> </ul>"},{"location":"wiki/#lvgl","title":"LVGL","text":"<ul> <li>How to Develop LVGL HMI Applications Using EEZ Studio</li> </ul>"},{"location":"wiki/#chromium","title":"Chromium","text":"<p>Coming Soon!! </p>"},{"location":"wiki/common_change-display-resolution/","title":"How to Change the Display Resolution","text":""},{"location":"wiki/common_change-display-resolution/#how-to-change-the-display-resolution","title":"How to Change the Display Resolution","text":"<p>This page describes how to change display resolution for weston (window manager).</p>"},{"location":"wiki/common_change-display-resolution/#1-edit-weston-configuration-file-to-change-display-resolution","title":"1. Edit weston configuration file to change display resolution","text":"<p>Weston has a configuration file '/etc/xdg/weston/weston.ini' in the root filesystem. You can change the display resolution by editing the file.</p> <p>You can use a text editor 'vi' to change the configuration file. To open and edit the file, execute 'vi' in the terminal for Linux running on the EVK as follows. </p><pre><code>vi /etc/xdg/weston/weston.ini\n</code></pre> <p>For information about 'vi', see Linux manual page. And you can find much more information about how to use 'vi' on the internet.</p> <p>If you want to edit the configuration file on your PC, insert your microSD card into your PC. You can edit the file in your microSD card directly. It may need root privileges.</p> <p>The configuration file consists of some sections, and the section has combinations of a key and a value. </p><pre><code>[section]\nkey1=&lt;value1&gt;\nkey2=&lt;value2&gt;\n</code></pre> <p>The display resolution is configured in 'output' section, and it is set with 'name' key and 'mode' key as follows. </p><pre><code>[output]\nname=&lt;connector&gt;\nmode=&lt;width&gt;x&lt;height&gt;\n</code></pre> <p>You can also set display resolution with a refresh rate in the 'mode' key as follows. </p><pre><code>[output]\nname=&lt;connector&gt;\nmode=&lt;width&gt;x&lt;height&gt;@&lt;refresh rate&gt;\n</code></pre> <p>When you use Linux in the HMI SDK, set 'HDMI-A-1' to 'name'. For example, if you want to set a display resolution of 1920x1080 and a refresh rate of 60Hz, add the following text to the configuration file. </p>/etc/xdg/weston/weston.ini<pre><code>[output]\nname=HDMI-A-1\nmode=1920x1080@60\n</code></pre> <p>To apply the change, you need to restart weston. Execute the following command in the terminal for Linux running on the EVK. </p><pre><code>systemctl restart weston@root\n</code></pre>"},{"location":"wiki/common_change-display-resolution/#2-check-available-display-resolutions","title":"2. Check available display resolutions","text":"<p>A display monitor can support several display resolutions. You can get a list of display resolutions supported by the display monitor that you are using.</p> <p>To get a list of display resolutions, execute 'weston-info' or 'modetest'.</p>"},{"location":"wiki/common_change-display-resolution/#1-weston-info","title":"1. weston-info","text":"<p>Execute 'weston-info' in the terminal for Linux running on the EVK as follows. </p><pre><code>weston-info\n</code></pre> <p>This command outputs many messages related to weston, but you need to check only information of 'wl_output'. For example: </p><pre><code>interface: 'wl_output', version: 3, name: 17\n        x: 0, y: 0, scale: 1,\n        physical_width: 260 mm, physical_height: 150 mm,\n        make: 'GEC', model: 'Onlap1102I',\n        subpixel_orientation: unknown, output_transform: normal,\n        mode:\n                width: 1920 px, height: 1080 px, refresh: 60.000 Hz,\n                flags: current preferred\n        mode:\n                width: 1920 px, height: 1080 px, refresh: 60.000 Hz,\n                flags:\n        mode:\n                width: 1920 px, height: 1080 px, refresh: 59.940 Hz,\n                flags:\n\n...\n\n        mode:\n                width: 640 px, height: 480 px, refresh: 60.000 Hz,\n                flags:\n        mode:\n                width: 640 px, height: 480 px, refresh: 59.940 Hz,\n                flags:\n        mode:\n                width: 640 px, height: 480 px, refresh: 59.940 Hz,\n                flags:\n</code></pre> <p>In the information of 'wl_output', all available display resolution are listed. The mode with the flags 'current' is the currently used mode.</p>"},{"location":"wiki/common_change-display-resolution/#2-modetest","title":"2. modetest","text":"<p>Execute 'modetest' in the terminal for Linux running on the EVK as follows. </p><pre><code>modetest -M rzg2l-du -c\n</code></pre> <p>This command output information about connectors, and it includes a list of modes (display resolution and refresh rate). For example: </p><pre><code>Connectors:\nid      encoder status          name            size (mm)       modes   encoders\n39      38      connected       HDMI-A-1        260x150         24      38\n  modes:\n        index name refresh (Hz) hdisp hss hse htot vdisp vss vse vtot)\n  #0 1920x1080 60.00 1920 2008 2052 2200 1080 1084 1089 1125 148500 flags: phsync, pvsync; type: preferred, driver\n  #1 1920x1080 60.00 1920 2008 2052 2200 1080 1084 1089 1125 148500 flags: phsync, pvsync; type: driver\n  #2 1920x1080 59.94 1920 2008 2052 2200 1080 1084 1089 1125 148352 flags: phsync, pvsync; type: driver\n  #3 1920x1080 50.00 1920 2448 2492 2640 1080 1084 1089 1125 148500 flags: phsync, pvsync; type: driver\n  #4 1920x1080 50.00 1920 2448 2492 2640 1080 1084 1089 1125 148500 flags: phsync, pvsync; type: driver\n  #5 1680x1050 59.88 1680 1728 1760 1840 1050 1053 1059 1080 119000 flags: phsync, nvsync; type: driver\n  #6 1600x900 60.00 1600 1624 1704 1800 900 901 904 1000 108000 flags: phsync, pvsync; type: driver\n  #7 1280x1024 60.02 1280 1328 1440 1688 1024 1025 1028 1066 108000 flags: phsync, pvsync; type: driver\n  #8 1440x900 59.90 1440 1488 1520 1600 900 903 909 926 88750 flags: phsync, nvsync; type: driver\n  #9 1280x800 59.91 1280 1328 1360 1440 800 803 809 823 71000 flags: phsync, nvsync; type: driver\n  #10 1280x720 60.00 1280 1390 1430 1650 720 725 730 750 74250 flags: phsync, pvsync; type: driver\n  #11 1280x720 60.00 1280 1390 1430 1650 720 725 730 750 74250 flags: phsync, pvsync; type: driver\n  #12 1280x720 59.94 1280 1390 1430 1650 720 725 730 750 74176 flags: phsync, pvsync; type: driver\n  #13 1280x720 50.00 1280 1720 1760 1980 720 725 730 750 74250 flags: phsync, pvsync; type: driver\n  #14 1024x768 60.00 1024 1048 1184 1344 768 771 777 806 65000 flags: nhsync, nvsync; type: driver\n  #15 800x600 60.32 800 840 968 1056 600 601 605 628 40000 flags: phsync, pvsync; type: driver\n  #16 720x576 50.00 720 732 796 864 576 581 586 625 27000 flags: nhsync, nvsync; type: driver\n  #17 720x480 60.00 720 736 798 858 480 489 495 525 27027 flags: nhsync, nvsync; type: driver\n  #18 720x480 60.00 720 736 798 858 480 489 495 525 27027 flags: nhsync, nvsync; type: driver\n  #19 720x480 59.94 720 736 798 858 480 489 495 525 27000 flags: nhsync, nvsync; type: driver\n  #20 720x480 59.94 720 736 798 858 480 489 495 525 27000 flags: nhsync, nvsync; type: driver\n  #21 640x480 60.00 640 656 752 800 480 490 492 525 25200 flags: nhsync, nvsync; type: driver\n  #22 640x480 59.94 640 656 752 800 480 490 492 525 25175 flags: nhsync, nvsync; type: driver\n  #23 640x480 59.94 640 656 752 800 480 490 492 525 25175 flags: nhsync, nvsync; type: driver\n  props:\n        1 EDID:\n\n...\n</code></pre> <p>You can choose one of the modes and set it to the weston configuration file.</p>"},{"location":"wiki/common_debug-application-with-gdb/","title":"How to Debug an Application with GDB","text":""},{"location":"wiki/common_debug-application-with-gdb/#how-to-debug-an-application-with-gdb","title":"How to Debug an Application with GDB","text":"<p>This guide describes the use of GDB to debug programs created in C on the EVK. For more detailed information about GDB, refer to Debugging with GDB.</p> <p>You need to connect your PC to the EVK, and you need to install the following terminal program to run and debug the target program on the EVK.</p> Windows PCLinux PC <p>Tera Term (terminal software)</p> <p>FTDI VCP driver</p> <p>minicom</p>"},{"location":"wiki/common_debug-application-with-gdb/#table-of-contents","title":"Table of Contents","text":"<ul> <li>1. How to use GDB<ul> <li>1-1. Give debugging symbols and execute compilation</li> <li>1-2. Execute the created program in GDB</li> <li>1-3. Stops a program running in GDB</li> <li>1-4. Exit GDB</li> <li>1-5. Display GDB help</li> </ul> </li> <li>2. Monitor program execution<ul> <li>2-1. Interrupts the execution of the program</li> <li>2-2. Continue program execution</li> <li>2-3. Check the interruption points of the program</li> <li>2-4. Execute the program code line by line</li> <li>2-5. Check the contents of program variables</li> <li>2-6. Change program variables</li> <li>2-7. Calls a specific function linked to the program</li> <li>2-8. Return from program functions</li> </ul> </li> <li>3. Set breakpoints<ul> <li>3-1. Set breakpoints on specific lines</li> <li>3-2. Set a breakpoint in the function</li> <li>3-3. Obtain a list of breakpoints</li> <li>3-4. Disable breakpoints</li> </ul> </li> <li>4. Set watchpoints<ul> <li>4-1. Set watchpoints for variable writes</li> <li>4-2. Set watchpoints for variable reads</li> <li>4-3. Set watchpoints for reading and writing variables</li> <li>4-4. Obtain a list of watchpoints</li> <li>4-5. Disable watchpoints</li> </ul> </li> <li>5. Execute call stack<ul> <li>5-1. Obtain a backtrace of the function</li> <li>5-2. Change the stack frame</li> <li>5-3. Analyze stack frames</li> </ul> </li> <li>6. Examples<ul> <li>6-1. Example 1 of infinite loop analysis</li> <li>6-2. Example 2 of infinite loop analysis</li> <li>6-3. Segmentation Fault Analysis Example</li> </ul> </li> </ul>"},{"location":"wiki/common_debug-application-with-gdb/#1-how-to-use-gdb","title":"1. How to use GDB","text":"<p>This chapter explains how to prepare for debugging an application and how to start/stop basic GDB.  </p> <p>The gdb command is not installed in the HMI SDK environment by default. To install gdb, you need to build HMI SDK environment after changing configuration. To build HMI SDK environment, see How to Build HMI SDK. In the build procedure, modify configuration file before you run bitbake command.</p> <ol> <li> <p>Open the configuration file </p><pre><code>cd ${WORK}/build\nvim conf/local.conf\n</code></pre> </li> <li> <p>Add the following settings to the configuration files </p><pre><code>WHITELIST_GPL-3.0 += \" tools-debug gdb autoconf-native bison-native gettext-native gnu-config-native readline\"\nIMAGE_INSTALL_append = \" gdb\"\nEXTRA_IMAGE_FEATURES_append = \" tools-debug\"\n</code></pre> </li> <li> <p>Run bitbake with gdb alone to make sure no error occurs. </p><pre><code>MACHINE=${BOARD} bitbake gdb\n</code></pre> </li> <li> <p>Run bitbake to build images (See How to Build HMI SDK.)</p> </li> </ol>"},{"location":"wiki/common_debug-application-with-gdb/#1-1-give-debugging-symbols-and-execute-compilation","title":"1-1. Give debugging symbols and execute compilation","text":"<p>The -g flag must be passed to the compiler to grant debugging symbols. Add the -g flag to the Makefile. Add the -O0 flag to disable optimization.</p> <p></p>Makefile<pre><code>APP = testprog\nSRC = main.c\nall: $(APP)\nCC = gcc\nCFLAGS = -g -O0 -Wall\n$(APP):\n        $(CC) -o $(APP) $(SRC) $(CFLAGS)\nclean:\n        rm -rf $(APP)\n</code></pre> The source code should be the following. main.c<pre><code>#include &lt;stdio.h&gt;\n\nint func1(int num)\n{\n   static int sum = 0;\n   sum += num;\n   return sum;\n}\n\nint main(int argc, char** argv)\n{\n   int num;\n   num = 1;\n   while(1){\n      if(num &gt; 5000){\n         break;\n      }\n      func1(num);\n   }\n   return 0;\n}\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#1-2-execute-the-created-program-in-gdb","title":"1-2. Execute the created program in GDB","text":"<p>Execute gdb with the program compiled with the -g flag as an argument. </p><pre><code># gdb testprog\n...\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from testprog...\n(gdb)\n</code></pre> The gdb prompt will be invoked, and the program will run when the run command is executed. When specifying arguments, enter arg1, arg2, and so on. <pre><code>(gdb) run arg1 arg2\nStarting program: /home/root/debug/testprog arg1 arg2\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#1-3-stops-a-program-running-in-gdb","title":"1-3. Stops a program running in GDB","text":"<p>To stop the program, use the kill command. </p><pre><code>(gdb) kill\nKill the program being debugged? (y or n) y\n[Inferior 1 (process 46857) killed]\n(gdb)\n</code></pre> To run the program again, execute the run command. <pre><code>(gdb) run\nStarting program: /home/root/debug/testprog\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#1-4-exit-gdb","title":"1-4. Exit GDB","text":"<p>To exit GDB, use the quit command. </p><pre><code>(gdb) quit\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#1-5-display-gdb-help","title":"1-5. Display GDB help","text":"<p>If you want to check the help for GDB commands, use the help command. </p><pre><code>(gdb) help\nList of classes of commands:\n\naliases -- Aliases of other commands.\nbreakpoints -- Making program stop at certain points.\ndata -- Examining data.\nfiles -- Specifying and examining files.\ninternals -- Maintenance commands.\nobscure -- Obscure features.\nrunning -- Running the program.\nstack -- Examining the stack.\nstatus -- Status inquiries.\nsupport -- Support facilities.\ntracepoints -- Tracing of program execution without stopping the program.\nuser-defined -- User-defined commands.\n\nType \"help\" followed by a class name for a list of commands in that class.\nType \"help all\" for the list of all commands.\nType \"help\" followed by command name for full documentation.\nType \"apropos word\" to search for commands related to \"word\".\nType \"apropos -v word\" for full documentation of commands related to \"word\".\nCommand name abbreviations are allowed if unambiguous.\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-monitor-program-execution","title":"2. Monitor program execution","text":"<p>This chapter explains how to interrupt a program while it is running and proceed in the code to check and rewrite the contents of variables.</p>"},{"location":"wiki/common_debug-application-with-gdb/#2-1-interrupts-the-execution-of-the-program","title":"2-1. Interrupts the execution of the program","text":"<p>Start the program. </p><pre><code>(gdb) run\nStarting program: /home/root/debug/testprog\n</code></pre> Then Ctrl+C to send a signal and stop execution. <pre><code>^C\nProgram received signal SIGINT, Interrupt.\n0x000055555555516e in main (argc=1, argv=0x7fffffffe3a8) at main.c:16\n16          func1(num);\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-2-continue-program-execution","title":"2-2. Continue program execution","text":"<p>To continue and resume an interrupted program, use the continue command. </p><pre><code>(gdb) continue\nContinuing.\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-3-check-the-interruption-points-of-the-program","title":"2-3. Check the interruption points of the program","text":"<p>Use the list command to display the code around the point where the program was interrupted. </p><pre><code>(gdb) list\n11        int num = 1;\n12        while(1){\n13          if(num &gt; 5000){\n14            break;\n15          }\n16          func1(num);\n17        }\n18        return 0;\n19      }\n20\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-4-execute-the-program-code-line-by-line","title":"2-4. Execute the program code line by line","text":"<p>To execute one line of code at a time with the program suspended, use the next or step command. The next command advances the program one line, and if there is a function, it skips over the function call and executes the next code. </p><pre><code>(gdb) next\n16          func1(num);\n(gdb) next\n13          if(num &gt; 5000){\n</code></pre> The step command advances the program one line and moves inside the function, if any. <pre><code>(gdb) step\n16          func1(num);\n(gdb) step\nfunc1 (num=1) at main.c:4\n4       {\n(gdb) step\n6         sum += num;\n(gdb) step\n7       }\n(gdb) step\nmain (argc=1, argv=0x7fffffffe3a8) at main.c:13\n13          if(num &gt; 5000){\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-5-check-the-contents-of-program-variables","title":"2-5. Check the contents of program variables","text":"<p>To check the contents of a variable, use the print command. </p><pre><code>(gdb) print num\n$1 = 1\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-6-change-program-variables","title":"2-6. Change program variables","text":"<p>To change the contents of a variable, use the set command. </p><pre><code>(gdb) set num = 5001\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-7-calls-a-specific-function-linked-to-the-program","title":"2-7. Calls a specific function linked to the program","text":"<p>Use the call command to call any function. </p><pre><code>(gdb) call func1(1)\n(gdb) step\nfunc1 (num=1) at main.c:4\n4       {\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#2-8-return-from-program-functions","title":"2-8. Return from program functions","text":"<p>To terminate execution of a function in the middle of a function and return to the caller, use the finish command. The return value is also displayed when the command is executed. </p><pre><code>(gdb) finish\nRun till exit from #0  func1 (num=1) at main.c:6\nmain (argc=1, argv=0x7fffffffe3a8) at main.c:14\n14          if(num &gt; 5000){\nValue returned is $3 = 287125699\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#3-set-breakpoints","title":"3. Set breakpoints","text":"<p>This chapter describes breakpoints. A breakpoint is a landmark point at which a program is interrupted at a specific line of code. Breakpoints can be set on arbitrary lines of code or functions, and debugging is possible after interrupting the program because of step command or print command.</p>"},{"location":"wiki/common_debug-application-with-gdb/#3-1-set-breakpoints-on-specific-lines","title":"3-1. Set breakpoints on specific lines","text":"<p>When set to line If there is only one source file, specify only the number of lines. </p><pre><code>(gdb) break 14\nBreakpoint 1 at 0x1167: file main.c, line 14.\n(gdb) run\nStarting program: /home/root/debug/testprog\n\nBreakpoint 1, main (argc=1, argv=0x7fffffffe3a8) at main.c:14\n14          if(num &gt; 5000){\n(gdb)\n</code></pre> If there are multiple source files, specify the file name and number of lines. <pre><code>(gdb) break main.c:6\nBreakpoint 1 at 0x1134: file main.c, line 6.\n(gdb) run\nStarting program: /home/root/debug/testprog\n\nBreakpoint 1, func1 (num=1) at main.c:6\n6         sum += num;\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#3-2-set-a-breakpoint-in-the-function","title":"3-2. Set a breakpoint in the function","text":"<p>When setting to a function, specify the function name. </p><pre><code>(gdb) break func1\nBreakpoint 1 at 0x1129: file main.c, line 4.\n(gdb) run\nStarting program: /home/root/debug/testprog\n\nBreakpoint 1, func1 (num=21845) at main.c:4\n4       {\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#3-3-obtain-a-list-of-breakpoints","title":"3-3. Obtain a list of breakpoints","text":"<p>Use the info breakpoints command to display a list of all currently set breakpoints. </p><pre><code>(gdb) info breakpoint\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep y   0x0000555555555129 in func1 at main.c:4\n        breakpoint already hit 1 time\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#3-4-disable-breakpoints","title":"3-4. Disable breakpoints","text":"<p>Use the disable command to disable the currently set breakpoint. The argument must be a breakpoint number to be obtained with info breakpoints. Disabled breakpoints will have an Enb of n. run execution will not stop at breakpoints. </p><pre><code>(gdb) disable 1\n(gdb) info breakpoints\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep n   0x0000555555555129 in func1 at main.c:4\n        breakpoint already hit 1 time\n(gdb) run\nStarting program: /home/root/debug/testprog\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#4-set-watchpoints","title":"4. Set watchpoints","text":"<p>This chapter describes the watchpoints. A watchpoint is a marker point at which the program is interrupted when a variable is accessed. Watchpoints can be set on arbitrary variables, and debugging is possible after interrupting the program because of step command or print command.</p>"},{"location":"wiki/common_debug-application-with-gdb/#4-1-set-watchpoints-for-variable-writes","title":"4-1. Set watchpoints for variable writes","text":"<p>If you want to interrupt the program when writing to a specific variable, use the watch command. Since the variable to be specified must be in the current scope, it should be used in conjunction with breakpoints.</p> <p>Set a breakpoint in the main function. </p><pre><code>(gdb) break main\nBreakpoint 1 at 0x114d: file main.c, line 11.\n(gdb) run\nStarting program: /home/root/debug/testprog\n\nBreakpoint 1, main (argc=21845, argv=0x0) at main.c:11\n11      {\n</code></pre> Set watchpoints in the num variable. <pre><code>(gdb) watch num\nHardware watchpoint 2: num\n(gdb) continue\nContinuing.\n</code></pre> Stops when writing num variables. <pre><code>Hardware watchpoint 2: num\n\nOld value = 0\nNew value = 1\nmain (argc=1, argv=0x7fffffffe3a8) at main.c:14\n14          if(num &gt; 5000){\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#4-2-set-watchpoints-for-variable-reads","title":"4-2. Set watchpoints for variable reads","text":"<p>If you want to interrupt the program when a specific variable is read, use the rwatch command. Usage notes are the same as for the watch command.</p> <p>Set a breakpoint in the func1 function. </p><pre><code>(gdb) break func1\nBreakpoint 1 at 0x1129: file main.c, line 4.\n(gdb) run\nStarting program: /home/root/debug/testprog\n\nBreakpoint 1, func1 (num=21845) at main.c:4\n4       {\n</code></pre> Stops when sum variable is read. <pre><code>(gdb) rwatch sum\nHardware read watchpoint 2: sum\n(gdb) continue\nContinuing.\n\nHardware read watchpoint 2: sum\n\nValue = 0\n0x000055555555513a in func1 (num=1) at main.c:6\n6         sum += num;\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#4-3-set-watchpoints-for-reading-and-writing-variables","title":"4-3. Set watchpoints for reading and writing variables","text":"<p>If you want to interrupt the program when either reading or writing a specific variable occurs, use the awatch command. Usage notes are the same as for the watch command.</p> <p>Set a breakpoint in the func1 function. </p><pre><code>(gdb) break func1\nBreakpoint 1 at 0x1129: file main.c, line 4.\n(gdb) run\nStarting program: /home/root/debug/testprog\n\nBreakpoint 1, func1 (num=21845) at main.c:4\nwarning: Source file is more recent than executable.\n4       {\n</code></pre> Stops when reading/writing sum variables. <pre><code>(gdb) awatch sum\nHardware access (read/write) watchpoint 2: sum\n(gdb) continue\nContinuing.\n</code></pre> Stop at readout. <pre><code>Hardware access (read/write) watchpoint 2: sum\n\nValue = 0\n0x000055555555513a in func1 (num=1) at main.c:6\n6         sum += num;\n(gdb) continue\nContinuing.\n</code></pre> Stop when writing. <pre><code>Hardware access (read/write) watchpoint 2: sum\n\nOld value = 0\nNew value = 1\nfunc1 (num=1) at main.c:7\n7         return sum;\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#4-4-obtain-a-list-of-watchpoints","title":"4-4. Obtain a list of watchpoints","text":"<p>Use the info breakpoints command to display a list of all currently set watchpoints. </p><pre><code>(gdb) info breakpoints\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep y   0x0000555555555129 in func1 at main.c:4\n        breakpoint already hit 1 time\n2       acc watchpoint keep y                      sum\n        breakpoint already hit 2 times\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#4-5-disable-watchpoints","title":"4-5. Disable watchpoints","text":"<p>Use the disable command to disable the currently set watchpoints. The argument must be a watchpoint number to be obtained with info breakpoints. Disabled watchpoints will have an Enb of n. run execution will not stop at the watchpoint. </p><pre><code>(gdb) disable 2\n(gdb) info breakpoints\nNum     Type           Disp Enb Address            What\n1       breakpoint     keep y   0x0000555555555129 in func1 at main.c:4\n        breakpoint already hit 1 time\n2       acc watchpoint keep n                      sum\n        breakpoint already hit 2 times\n(gdb) continue\nContinuing.\n\nBreakpoint 1, func1 (num=1) at main.c:4\n4       {\n(gdb) continue\nContinuing.\n\nBreakpoint 1, func1 (num=1) at main.c:4\n4       {\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#5-execute-call-stack","title":"5. Execute call stack","text":"<p>This chapter explains how to analyze stacked frames. The execution status of the function can be checked by analyzing the stack frame.</p>"},{"location":"wiki/common_debug-application-with-gdb/#5-1-obtain-a-backtrace-of-the-function","title":"5-1. Obtain a backtrace of the function","text":"<p>Use the backtrace command to obtain a backtrace, which is information about the caller of a function. </p><pre><code>(gdb) backtrace\n#0  func1 (num=1) at main.c:4\n#1  0x000055555555517a in main (argc=1, argv=0x7fffffffe3a8) at main.c:17\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#5-2-change-the-stack-frame","title":"5-2. Change the stack frame","text":"<p>To change the stack frame, use the frame command. Get the frame number with the backtrace command and use it as an argument. </p><pre><code>(gdb) frame 1\n#1  0x000055555555517a in main (argc=1, argv=0x7fffffffe3a8) at main.c:17\n17          func1(num);\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#5-3-analyze-stack-frames","title":"5-3. Analyze stack frames","text":"<p>Three commands to check the contents of the current stack frame are described. The info frame command outputs detailed information such as register values for the current stack frame. </p><pre><code>(gdb) info frame\nStack level 1, frame at 0x7fffffffe2c0:\n rip = 0x55555555517a in main (main.c:17); saved rip = 0x7ffff7de4083\n caller of frame at 0x7fffffffe290\n source language c.\n Arglist at 0x7fffffffe288, args: argc=1, argv=0x7fffffffe3a8\n Locals at 0x7fffffffe288, Previous frame's sp is 0x7fffffffe2c0\n Saved registers:\n  rbp at 0x7fffffffe2b0, rip at 0x7fffffffe2b8\n(gdb)\n</code></pre> The info locals command displays a list of local variables and their values for the current stack frame. <pre><code>(gdb) info locals\nnum = 1\n(gdb)\n</code></pre> The info args command displays a list of arguments for the current stack frame. <pre><code>(gdb) info args\nargc = 1\nargv = 0x7fffffffe3a8\n(gdb)\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#6-examples","title":"6. Examples","text":""},{"location":"wiki/common_debug-application-with-gdb/#6-1-example-1-of-infinite-loop-analysis","title":"6-1. Example 1 of infinite loop analysis","text":"<p>The source code should be the following. The value of num is added and the program terminates when it exceeds 5000.</p> <p></p>main.c<pre><code>#include &lt;stdio.h&gt;\n\nint func1(int num)\n{\n   static int sum = 0;\n   sum += num;\n   return sum;\n}\n\nint main(int argc, char** argv)\n{\n   int num;\n   num = 1;\n   while(1){\n      if(num &gt; 5000){\n         break;\n      }\n      func1(num);\n   }\n   return 0;\n}\n</code></pre> Compile the program with the -g option. When the program is executed, it falls into an infinite loop. <pre><code># ./testprog\n</code></pre> Debugging with gdb. <pre><code># gdb testprog\n...\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from testprog...\n(gdb) run\nStarting program: /home/root/debug/testprog\n</code></pre> The program is interrupted by Ctrl+C because it falls into an infinite loop. <pre><code>^C\nProgram received signal SIGINT, Interrupt.\nfunc1 (num=1) at main.c:8\n8       }\n(gdb)\n</code></pre> Advance the program with the next command. <pre><code>(gdb) next\nmain (argc=1, argv=0x7fffffffe3a8) at main.c:15\n15          if(num &gt; 5000){\n(gdb) next\n18          func1(num);\n(gdb) next\n15          if(num &gt; 5000){\n(gdb) next\n18          func1(num);\n(gdb) next\n15          if(num &gt; 5000){\n(gdb)\n</code></pre> The same pattern is repeated, and this code does not update the value of num. Since the condition for exiting the loop is that num must exceed 5000, the fact that num did not change was the cause of the infinite loop. <pre><code>      if(num &gt; 5000){\n         break;\n      }\n</code></pre> The func1 function adds the value of num to sum and returns it, so the expected behavior is to receive that value in the main function. <pre><code>int func1(int num)\n{\n   static int sum = 0;\n   sum += num;\n   return sum;\n}\n</code></pre> <pre><code>while(1){\n   if(num &gt; 5000){\n      break;\n   }\n   num = func1(num);\n}\n</code></pre>"},{"location":"wiki/common_debug-application-with-gdb/#6-2-example-2-of-infinite-loop-analysis","title":"6-2. Example 2 of infinite loop analysis","text":"<p>The source code should be the following. This program stores 300 values calculated from a counter in an array of ints.</p> <p></p>main.c<pre><code>#include &lt;stdio.h&gt;\n\n#define DATANUM 300\n\nint getdata(unsigned char cnt)\n{\n  return (int)cnt*(cnt+cnt);\n}\n\nint main(int argc, char** argv)\n{\n  unsigned char cnt = 0;\n  int data[DATANUM];\n\n  for(cnt = 0;cnt &lt; DATANUM;cnt++){\n    data[cnt] = getdata(cnt);\n  }\n\n  return 0;\n}\n</code></pre> Compile the program with the -g option.  When the program is executed, it falls into an infinite loop. <pre><code># ./testprog\n</code></pre> Debugging with gdb. <pre><code># gdb testprog\n...\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from testprog...\n(gdb) run\nStarting program: /home/root/debug/testprog\n</code></pre> The program is interrupted by Ctrl+C because it falls into an infinite loop. <pre><code>^C\nProgram received signal SIGINT, Interrupt.\ngetdata (cnt=106 'j') at main3.c:6\n6       {\n(gdb)\n</code></pre> Since the loop does not end, we confirmed that if we advance the program with the step command until cnt reaches 300, which is the intended end condition, cnt returns to 0 in the middle of the loop. <pre><code>(gdb)step\ngetdata (cnt=255 '\\377') at main3.c:6\n6       {\n(gdb)step\n7         return (int)cnt*(cnt+cnt);\n(gdb)step\n8       }\n(gdb)step\nmain (argc=1, argv=0x7fffffffe3a8) at main3.c:15\n15        for(cnt = 0;cnt &lt; DATANUM;cnt++){\n(gdb)step\n16          data[cnt] = getdata(cnt);\n(gdb)step\ngetdata (cnt=0 '\\000') at main3.c:6\n6       {\n(gdb)\n</code></pre> The fact that cnt returns to 0 at 255 means that cnt cannot hold more than 256, so the counter variable may not be of the correct type. I checked the counter variable and found that cnt is defined as unsigned char (0-255). This would have resulted in an infinite loop because the loop termination condition of 300 would never be reached. <pre><code>unsigned char cnt = 0;\n</code></pre> The expected behavior is achieved by setting the type of cnt to unsigned short (0-65535)."},{"location":"wiki/common_debug-application-with-gdb/#6-3-segmentation-fault-analysis-example","title":"6-3. Segmentation Fault Analysis Example","text":"<p>The source code should be the following. Allocates memory with malloc and initializes buffers.</p> <p></p>main.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char** argv)\n{\n  char *buf;\n  buf = malloc(1&lt;&lt;31);\n  memset(buf,0x00,1024);\n  return 0;\n}\n</code></pre> Compile the program with the -g option. Segmentation fault occurs when the program is executed. <pre><code># ./testprog\nSegmentation fault (core dumped)\n</code></pre> Debugging with gdb. <pre><code># gdb testprog\n...\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from testprog...\n(gdb) run\nStarting program: /home/root/debug/testprog\n\nProgram received signal SIGSEGV, Segmentation fault.\n__memset_avx2_unaligned_erms () at ../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:200\n200     ../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S: No such file or directory.\n(gdb)\n</code></pre> Check backtrace as SIGSEGV occurs. <pre><code>(gdb) backtrace\n#0  __memset_avx2_unaligned_erms () at ../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:200\n#1  0x00005555555551a2 in main (argc=1, argv=0x7fffffffe3a8) at main.c:9\n(gdb)\n</code></pre> Segmentation fault occurs at line 9 of the code, so the frame is switched. <pre><code>(gdb) frame 1\n#1  0x00005555555551a2 in main (argc=1, argv=0x7fffffffe3a8) at main.c:9\n9         memset(buf,0x00,1024);\n(gdb)\n</code></pre> Segmentation fault occurs in memset, so I check the buf contents and the buf address is NULL. <pre><code>(gdb) print buf\n$1 = 0x0\n(gdb)\n</code></pre> Once the program is finished, set a breakpoint in the main function and a watchpoint in buf. <pre><code>(gdb) kill\nKill the program being debugged? (y or n) y\n[Inferior 1 (process 47511) killed]\n(gdb) break main\nBreakpoint 1 at 0x555555555169: file main.c, line 6.\n(gdb) run\nStarting program: /home/pokyuser/hello_apl/testprog\n\nBreakpoint 1, main (argc=21845, argv=0x0) at main.c:6\n6       {\n(gdb) awatch buf\nHardware access (read/write) watchpoint 2: buf\n(gdb)\n</code></pre> Checking the buf pointer change, it remains NULL even after allocating memory with malloc. <pre><code>(gdb) continue\nContinuing.\n\nHardware access (read/write) watchpoint 2: buf\n\nValue = 0x0\nmain (argc=1, argv=0x7fffffffe3a8) at main.c:9\n9         memset(buf,0x00,1024);\n(gdb) continue\nContinuing.\n\nHardware access (read/write) watchpoint 2: buf\n\nValue = 0x0\n0x0000555555555190 in main (argc=1, argv=0x7fffffffe3a8) at main.c:9\n9         memset(buf,0x00,1024);\n(gdb) continue\nContinuing.\n\nProgram received signal SIGSEGV, Segmentation fault.\n__memset_avx2_unaligned_erms () at ../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:200\n200     ../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S: No such file or directory.\n(gdb)\n</code></pre> Check the malloc function to confirm that malloc is specified to return NULL if memory cannot be allocated. <pre><code>buf = malloc(1&lt;&lt;31);\n</code></pre> The memory size being allocated by malloc was 4 GB, and NULL was returned because the huge size was not allocated. Since the size set in memset is 1024 bytes, the problem can be solved by either setting the size to be acquired by malloc to 1024 as well or checking the return value of malloc, and if it is NULL, do not access it, etc."},{"location":"wiki/common_qspi-boot-mode/","title":"How to Boot from a microSD Card in QSPI Boot Mode","text":""},{"location":"wiki/common_qspi-boot-mode/#how-to-boot-from-a-microsd-card-in-qspi-boot-mode","title":"How to Boot from a microSD Card in QSPI Boot Mode","text":"<p>This page describes how to boot Linux of the HMI SDK from a microSD card in QSPI boot mode.</p> <p>Please note that you need to update bootloaders in Flash ROM on the EVK to use the QSPI boot mode.  In the eSD boot mode, bootloaders stored in the microSD card are used, but bootloaders stored in the ROM are used when you use the QSPI boot mode.  For information about how to update bootloaders, see How to Update Firmware (Flash Writer and Bootloaders).</p>"},{"location":"wiki/common_qspi-boot-mode/#1-create-a-bootable-microsd-card","title":"1. Create a bootable microSD card","text":"<p>Get a microSD card ready. For information about requirements for the microSD card, see Necessary Equipment. And for information about how to create a bootable microSD card, see Step 4: Create SD Cards with the Prebuilt Image.</p>"},{"location":"wiki/common_qspi-boot-mode/#2-set-boot-mode-to-qspi-boot-mode","title":"2. Set boot mode to QSPI boot mode","text":"<p>To use QSPI boot mode, set the SW11 as follows.</p> <p></p> SW11-1 SW11-2 SW11-3 SW11-4 OFF OFF OFF ON"},{"location":"wiki/common_qspi-boot-mode/#3-set-bootable-microsd-card","title":"3. Set bootable microSD card","text":"<p>Insert the bootable microSD card into the card slot on RZ SMARC Carrier Board.</p> <p></p> <p>Note</p> <p>Please note that the card slot is different from a card slot used for eSD boot.</p>"},{"location":"wiki/common_qspi-boot-mode/#4-boot-linux-on-the-board","title":"4. Boot Linux on the board","text":"<p>Press and hold power button (SW9) for 1 second to turn on the EVK. You will see the following messages in the console.</p> <pre><code>U-Boot 2021.10 (Dec 15 2023 - 06:47:44 +0000)\n\nCPU:   Renesas Electronics CPU rev 1.0\nModel: smarc-rzg2l\nDRAM:  1.9 GiB\nMMC:   sd@11c00000: 0, sd@11c10000: 1\nLoading Environment from MMC... OK\n\nIn:    serial@1004b800\nOut:   serial@1004b800\nErr:   serial@1004b800\nU-boot WDT started!\nNet:   \nError: ethernet@11c20000 address not set.\nNo ethernet found.\n\nHit any key to stop autoboot:  2  1  0 \nswitch to partitions #0, OK\nmmc1 is current device\n19857920 bytes read in 1229 ms (15.4 MiB/s)\n39079 bytes read in 6 ms (6.2 MiB/s)\nMoving Image from 0x48080000 to 0x48200000, end=49350000\n## Flattened Device Tree blob at 48000000\n   Booting using the fdt blob at 0x48000000\n   Loading Device Tree to 0000000057ff3000, end 0000000057fff6fc ... OK\n\nStarting kernel ...\n\n[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x412fd050]\n[    0.000000] Linux version 5.10.184-cip36-yocto-standard (oe-user@oe-host) \n...\n    (omitted)\n...\n\nPoky (Yocto Project Reference Distro) 3.1.26 smarc-rzg2l ttySC0\n\nBSP: RZG2L/RZG2L-SMARC-EVK/3.0.6-update3\nLSI: RZG2L\nVersion: 3.0.6-update3\nsmarc-rzg2l login: root\nroot@smarc-rzg2l:~#\n</code></pre> <p>You can login as root without password.</p> <p>Note</p> <p>The messages in the console depend on the EVK and software that you are using.</p> <p>If you are faced with an error in the boot process, it may be caused by u-boot configuration. See Configure U-boot.</p>"},{"location":"wiki/common_qspi-boot-mode/#5-shutdown","title":"5. Shutdown","text":"<p>To shut down the system, run shutdown command as follows.</p> <p></p><pre><code>shutdown -h now\n</code></pre> <p>After you executing the shutdown command, it shuts down the system immediately. And when it completes, you will see the following message.</p> <pre><code>reboot: Power down\n</code></pre> <p>Then, press and hold power button (SW9) for 2 seconds to turn off the EVK.</p>"},{"location":"wiki/common_qspi-boot-mode/#appendix","title":"Appendix","text":""},{"location":"wiki/common_qspi-boot-mode/#configure-u-boot","title":"Configure U-boot","text":"<p>U-boot is configured for QSPI/SD boot mode by default. But if you used other modes, the configuration has been changed. In that case, initialize U-boot configuration as follows.</p> <p>Turn on the EVK, and hit any key to stop autoboot after you see the following messages in the console.</p> <pre><code>U-Boot 2021.10 (Mar 31 2022 - 03:57:20 +0000)\n\nCPU: Renesas Electronics K rev 16.10\nModel: smarc-rzg2l\nDRAM: 1.9 GiB\nMMC: sd@11c00000: 0, sd@11c10000: 1\nLoading Environment from MMC... OK\nIn: serial@1004b800\nOut: serial@1004b800\nErr: serial@1004b800\nNet:\nError: ethernet@11c20000 address not set.\nNo ethernet found.\n\nHit any key to stop autoboot:\n</code></pre> <p>Then, input the following command to restore the default configuration.</p> <p></p><pre><code>env default -a\n</code></pre> <p>Save the configuration by saveenv command.</p> <p></p><pre><code>saveenv\n</code></pre> <p>To start Linux on the EVK, press reset switch (SW10).</p>"},{"location":"wiki/common_update-firmware/","title":"How to Update Firmware (Flash Writer and Bootloaders)","text":""},{"location":"wiki/common_update-firmware/#how-to-update-firmware-flash-writer-and-bootloaders","title":"How to Update Firmware (Flash Writer and Bootloaders)","text":"<p>When you use QSPI boot mode or eMMC boot mode, you should update firmware (bootloaders). This page describes how to write flash writer and bootloaders. To write flash writer and bootloaders, you need to connect your PC to the EVK with a USB serial cable. See \"Setup EVK's peripheral\". And The following tools are used in this instructions. Please install them to your PC in advance.</p> Windows PCLinux PC <p>Tera Term (terminal software)</p> <p>FTDI VCP driver</p> <p>minicom</p> <p>For information about how to use QSPI boot, see Boot Linux from microSD card. And for information about how to use eMMC boot, refer to RZ/G2L, RZ/G2LC and RZ/G2UL-EVKIT Linux Start-up Guide.</p>"},{"location":"wiki/common_update-firmware/#1-set-boot-mode-to-scif-download-mode","title":"1. Set boot mode to SCIF download mode","text":"<p>Turn off the power of EVK, then set the SW11 as follows.</p> <p></p> SW11-1 SW11-2 SW11-3 SW11-4 OFF ON OFF ON"},{"location":"wiki/common_update-firmware/#2-configure-terminal-software","title":"2. Configure terminal software","text":"<p>Configure the setting of serial communication on terminal software as follows:</p> <ul> <li>Speed: 115200 bps</li> <li>Data: 8bit</li> <li>Parity: None</li> <li>Stop bit: 1 bit</li> <li>Flow control: None</li> </ul>"},{"location":"wiki/common_update-firmware/#3-prepare-flash-writer-and-bootloaders","title":"3. Prepare flash writer and bootloaders","text":"<p>The flash writer and the bootloaders are stored in the pre-built binaries package of the HMI SDK.  See file contents.</p> <p>Unzip the pre-built binaries package to pick up flash write and bootloaders as follows:</p> RZ/G2LRZ/G2LCRZ/G2UL <p></p><pre><code>unzip pre-built-binary_rzg2l_hmi-sdk_v*.zip\n</code></pre> <ul> <li> <p>Flash writer</p> <ul> <li>Flash_Writer_SCIF_RZG2L_SMARC_PMIC_DDR4_2GB_1PCS.mot</li> </ul> </li> <li> <p>Bootloaders</p> <ul> <li>bl2_bp-smarc-rzg2l_pmic.srec</li> <li>fip-smarc-rzg2l_pmic.srec</li> </ul> </li> </ul> <p></p><pre><code>unzip pre-built-binary_rzg2lc_hmi-sdk_v*.zip\n</code></pre> <ul> <li> <p>Flash writer</p> <ul> <li>Flash_Writer_SCIF_RZG2LC_SMARC_DDR4_1GB_1PCS.mot</li> </ul> </li> <li> <p>Bootloaders</p> <ul> <li>bl2_bp-smarc-rzg2lc.srec</li> <li>fip-smarc-rzg2lc.srec</li> </ul> </li> </ul> <p></p><pre><code>unzip pre-built-binary_rzg2ul_hmi-sdk_v*.zip\n</code></pre> <ul> <li> <p>Flash writer</p> <ul> <li>Flash_Writer_SCIF_RZG2UL_SMARC_DDR4_1GB_1PCS.mot</li> </ul> </li> <li> <p>Bootloaders</p> <ul> <li>bl2_bp-smarc-rzg2ul.srec</li> <li>fip-smarc-rzg2ul.srec</li> </ul> </li> </ul>"},{"location":"wiki/common_update-firmware/#4-download-flash-writer-to-ram","title":"4. Download flash writer to RAM","text":"<p>Turn on the power of the EVK by pressing SW9. The messages below are shown on the terminal.</p> <pre><code> SCIF Download mode\n (C) Renesas Electronics Corp.\n-- Load Program to System RAM ---------------\nplease send !\n</code></pre> <p>Send an image of flash writer using terminal software after the message \"please send !\" is shown.</p> Windows PC (Tera Term)Linux PC (minicom) <p>Open the \"File\" menu, then select \"Send file...\" to open \"Send file\" dialg.</p> <p>Select the flash writer image in the dialog, and press \"Open\" button.</p> <p>Press \"Ctrl + A\", and \"S\", then select \"ascii\" for upload mode.</p> <p>Select the flash writer image file.</p> <p>Press any key when upload is completed.</p> <p>After successfully downloading the image, the flash writer starts automatically and shows a message like below on the terminal. </p><pre><code>Flash writer for RZ/G2 Series V1.06 Aug.10,2022                                                    \n Product Code : RZ/G2UL Type1   \n&gt;\n</code></pre>"},{"location":"wiki/common_update-firmware/#5-write-the-bootloaders","title":"5. Write the bootloaders","text":""},{"location":"wiki/common_update-firmware/#5-1-change-baud-rate-of-serial-port","title":"5-1. Change baud rate of serial port","text":"<p>Before writing the loader files, change the flash writer transfer rate from default (115200bps) to high speed (921600bps) with \"SUP\" command. </p><pre><code>SUP\n</code></pre> <p>After the \"SUP\" command, change the serial communication protocol speed from 115200bps to 921600bps on the terminal software.</p>"},{"location":"wiki/common_update-firmware/#5-2-write-bl2-file","title":"5-2. Write bl2 file","text":"<p>Execute \"XLS2\" command to write boot loader binary files.  </p><pre><code>XLS2\n</code></pre> <p>This command receives binary data from the serial port and writes the data to a specified address of the Flash ROM with information where the data should be loaded on the address of the main memory.  Set the following addresses respectively.</p> <ul> <li>Address to load to RAM: H'11E00</li> <li>Address to save to ROM: H'00000</li> </ul> <p>For example: </p><pre><code>&gt;XLS2                                                                                              \n===== Qspi writing of RZ/G2 Board Command =============                                            \nLoad Program to Spiflash                                                                           \nWrites to any of SPI address.                                                                      \n Dialog : AT25QL128A                                                                               \nProgram Top Address &amp; Qspi Save Address                                                            \n===== Please Input Program Top Address ============                                                \n  Please Input : H'11E00                                                                           \n                                                                                                   \n===== Please Input Qspi Save Address ===                                                           \n  Please Input : H'00000                                                                           \nWork RAM(H'50000000-H'53FFFFFF) Clear....                                                          \nplease send ! ('.' &amp; CR stop load)\n</code></pre> <p>Send the data of \"bl2_bp-smarc-rzg2*.srec\" from terminal software in the same way as the flash writer after the message \"please send !\" is shown.  For the actual file name of bl2 file, see 3. Prepare flash writer and bootloaders.</p> <p>In the case that the following message is shown, enter 'y'. </p><pre><code>SPI Data Clear(H'FF) Check :H'00000000-0000FFFF,Clear OK?(y/n)\n</code></pre> <p>After writing the data is completed, the following messages like below are shown on the terminal. </p><pre><code>SPI Data Clear(H'FF) Check :H'00000000-0000FFFF Erasing..Erase Completed \nSAVE SPI-FLASH.......\n======= Qspi  Save Information  =================\n SpiFlashMemory Stat Address : H'00000000\n SpiFlashMemory End Address  : H'0000CA38\n===========================================================\n\n&gt;\n</code></pre>"},{"location":"wiki/common_update-firmware/#5-3-write-fip-file","title":"5-3. Write fip file","text":"<p>Execute \"XLS2\" command to write fip file.  </p><pre><code>XLS2\n</code></pre> <p>Set the following addresses respectively for the fip file.</p> <ul> <li>Address to load to RAM: H'00000</li> <li>Address to save to ROM: H'1D200</li> </ul> <p>For example: </p><pre><code>&gt;XLS2\n===== Qspi writing of RZ/G2 Board Command =============\nLoad Program to Spiflash\nWrites to any of SPI address.\n Dialog : AT25QL128A\nProgram Top Address &amp; Qspi Save Address \n===== Please Input Program Top Address ============\n  Please Input : H'00000\n \n===== Please Input Qspi Save Address ===\n  Please Input : H'1D200\nWork RAM(H'50000000-H'53FFFFFF) Clear....\nplease send ! ('.' &amp; CR stop load)\n</code></pre> <p>Send the data of \"fip-smarc-rzg2*.srec\" from terminal software in the same way as the flash writer after the message \"please send !\" is shown.  For the actual file name of fip file, see 3. Prepare flash writer and bootloaders.</p> <p>In the case that the following message is shown, enter 'y'. </p><pre><code>SPI Data Clear(H'FF) Check :H'00010000-000DFFFF,Clear OK?(y/n)\n</code></pre> <p>After writing the data is completed, the following messages like below are shown on the terminal. </p><pre><code>SPI Data Clear(H'FF) Check :H'00010000-000DFFFF Erasing..............Erase Completed \nSAVE SPI-FLASH.......\n======= Qspi  Save Information  =================\n SpiFlashMemory Stat Address : H'0001D200\n SpiFlashMemory End Address  : H'000DD9EF\n===========================================================\n\n&gt;\n</code></pre>"},{"location":"wiki/common_update-firmware/#5-4-restore-baud-rate-of-serial-port","title":"5-4. Restore baud rate of serial port","text":"<p>After writing two loader files is completed, restore the serial communication protocol speed to 115200bps on the terminal software. Then, turn off the power of the board by pressing the SW9.</p>"},{"location":"wiki/common_update-linux-package/","title":"How to Update Linux Packages in the HMI SDK","text":""},{"location":"wiki/common_update-linux-package/#how-to-update-linux-packages-in-the-hmi-sdk","title":"How to Update Linux Packages in the HMI SDK","text":"<p>The HMI SDK is configured using RZ/G Verified Linux Package (hereinafter referred to as \"VLP/G\") or Board Support Package (hereinafter referred to as \"BSP\"). When the VLP/G or the BSP in the HMI SDK is updated to fix issues, you can replace the VLP/G or the BSP with new one.</p>"},{"location":"wiki/common_update-linux-package/#updates-of-vlpg-v307","title":"Updates of VLP/G v3.0.7","text":"<p>HMI SDK v2.3.1.0 uses VLP/G v3.0.7, but some issues were detected in the VLP/G. VLP/G v3.0.7-update3 was released to address vulnerabilities and improve drivers in VLP/G v3.0.7.</p>"},{"location":"wiki/common_update-linux-package/#changes","title":"Changes","text":"<p>Changes in VLP/G v3.0.7-update3 are listed below.</p> Features Description Kernel The VLP/G v3.0.7-update3 includes several minor kernel fixes. U-Boot Update vmmc and vqmmc settings for eSD mode. Configure U-Boot to set a random MAC address. CVE-2024-53104 Fix out-of-bounds write by skipping UVC_VS_UNDEFINED frame parsing in uvc_parse_format (media: uvcvideo). CVE-2025-4802 The VLP/G v3.0.7-update3 includes the patch for the glibc vulnerability. glib-2.0 Updated to glib2.0_2.58.3-2+deb10u8. multimedia Update runtime dependencies, fix MMNGR issues, and add GRAY10_LE64 support to GStreamer. attr, binutils, busybox, coreutils, gcc-8, gnupg2, gzip, kbd, libassuan, libgcrypt20, libunistring, nss, openssh, openssl, perl, pkg-config, pseudo, quilt Switch to the ELTS mirror to prevent removal from the Debian Buster mirror:  - attr, coreutils, gcc-8, gnupg2, gzip, kbd, libassuan, libgcrypt20, libunistring, nss, perl, pkg-config, pseudo, quilt  Upgraded packages:  - binutils 2.31.1-16 -&gt; 2.31.1-16+deb10u1  - busybox 1.30.1-4 -&gt; 1.30.1-4+deb10u1  - openssh 7.9p1-10+deb10u2 -&gt; 7.9p1-10+deb10u5  - openssl 1.1.1n-0+deb10u6 -&gt; 1.1.1n-0+deb10u7 SSI Driver Fix random recording failures in full-duplex communication mode (RZ/G2L Series and RZ/G3S). PCIe Driver Enables NVMe PCIe support (RZ/G3S only). <p>For more detailed information about VLP/G v3.0.7-update3, get RZ/G Verified Linux Package v3.0.7 (RTK0EF0045Z0021AZJ-v3.0.7-update3) and check the release note in the package.</p>"},{"location":"wiki/common_update-linux-package/#how-to-update-vlpg-from-v307-to-v307-update3","title":"How to Update VLP/G from v3.0.7 to v3.0.7-update3","text":"<p>To update VLP/G v3.0.7 in HMI SDK v2.3.1.0, build the HMI SDK by following the instructions below.</p>"},{"location":"wiki/common_update-linux-package/#i-first-perform-instructions-at-step-1-and-1-through-4-at-step-2-in-how-to-build-hmi-sdk","title":"i. First, perform instructions at step 1 and #1 through #4 at step 2 in How To Build HMI SDK.","text":"<p>Note</p> <p>You do not need to download the HMI SDK source code package at step 1. Due to the update of the VLP/G, source codes of some modules were updated. So, you will get new source codes over a network in this build process.</p>"},{"location":"wiki/common_update-linux-package/#ii-next-replace-meta-renesas-with-new-one-as-follows","title":"ii. Next, replace meta-renesas with new one as follows:","text":"<pre><code>cd ${WORK}\nrm -rf meta-renesas\ngit clone https://github.com/renesas-rz/meta-renesas.git\ncd meta-renesas/\ngit checkout -b tmp BSP-3.0.7-update3\n</code></pre>"},{"location":"wiki/common_update-linux-package/#iii-then-proceed-with-5-through-8-at-step-2-in-how-to-build-hmi-sdk-but-skip-7-at-step-2","title":"iii. Then, proceed with #5 through #8 at step 2 in How To Build HMI SDK, but skip #7 at step 2.","text":"<p>Note</p> <p>You can skip #7 at step 2 because it shows instructions for offline build using the source code package.</p>"},{"location":"wiki/common_update-linux-package/#iv-finally-run-bitbake-command-to-build-images","title":"iv. Finally, run <code>bitbake</code> command to build images.","text":"RZ/G2LRZ/G2LCRZ/G2UL <pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston\n</code></pre> <p>Note</p> <p>A change of EMMC setting in #9 at step 2 is no longer necessary for VLP/G v3.0.7-update3.</p> <p>If you need to create an SDK toolchain, run <code>bitbake</code> command as follows. </p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston -c populate_sdk\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston\n</code></pre> <p>Note</p> <p>A change of SW_SD0_DEV_SEL setting in #9 at step 2 is no longer necessary for VLP/G v3.0.7-update3.</p> <p>If you need to create an SDK toolchain, run <code>bitbake</code> command as follows. </p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-weston -c populate_sdk\n</code></pre> <p></p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-bsp\n</code></pre> <p>If you need to create an SDK toolchain, run <code>bitbake</code> command as follows. </p><pre><code>cd ${WORK}/build\nMACHINE=${BOARD} bitbake core-image-bsp -c populate_sdk\n</code></pre> <p>After building images or SDK toolchain, you can find them in the following directories, respectively.</p> <ul> <li>Images: <code>${WORK}/build/tmp/deploy/images/${BOARD}/</code></li> <li>SDK toolchain: <code>${WORK}/build/tmp/deploy/sdk/</code></li> </ul>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/","title":"How to Develop LVGL HMI Applications Using EEZ Studio","text":""},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#how-to-develop-lvgl-hmi-applications-using-eez-studio","title":"How to Develop LVGL HMI Applications Using EEZ Studio","text":"<p>EEZ Studio is a free and cross-platform tool that can be used for development of LVGL GUIs. It is an open-source tool licensed under GPL v3.</p> <p>This guide describes the use of EEZ Studio to develop LVGL GUI applications. For detailed information about EEZ Studio, see EEZ Studio documentation because this guide provides only basic information.</p>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#installation","title":"Installation","text":""},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#in-the-case-of-windows-pc","title":"In the case of Windows PC","text":"<ol> <li> <p>Get the EEZ Studio installer 'EEZ-Studio-Setup-x.xx.x.exe' from the GitHub page.   </p> </li> <li> <p>Double-click the downloaded installer and agree to the software license agreement to start installation.</p> </li> </ol>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#in-the-case-of-linux-pc-ubuntu","title":"In the case of Linux PC (Ubuntu)","text":"<ol> <li> <p>Get the EEZ Studio installer 'eezstudio_x.xx.x_amd64.deb' from the GitHub page. If you cannot find the installer in the list, click 'Show all xx assets' at the bottom of the list to show all items.   </p> </li> <li> <p>Double-click the downloaded installer and click the Install button.   </p> </li> <li> <p>Enter the login password and click Authenticate to start the installation.   </p> </li> </ol>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#development-of-gui","title":"Development of GUI","text":"<p>The development flow described in this guide is as follows.</p> <ol> <li>Create GUI and generate source code in EEZ Studio on your PC.</li> <li>Build the GUI application from the generated source code on your Linux PC.</li> <li>Copy the built executable file into a microSD card and run it on the EVK.</li> </ol>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#1-create-gui-and-generate-source-code","title":"1. Create GUI and Generate source code","text":"<p>You can create LVGL GUI applications using EEZ Studio on your PC. And it supports generating source code.</p>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#creating-a-project","title":"Creating a project","text":"<ol> <li> <p>Start EEZ Studio, select \"File\" on the left tab and choose \"New Project\".   </p> </li> <li> <p>Select \"LVGL\" and enter an arbitrary project name in PROJECT SETTINGS and press Create Project.   </p> </li> </ol>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#creating-gui","title":"Creating GUI","text":"<ol> <li> <p>Adding widgets Drag and drop the necessary widgets (e.g. Arc) from the Components Palettes.    </p> </li> <li> <p>Change the size and display of widgets You can resize the widgets (e.g. Arc) by expanding the blue frame.    You can also change the size from POSITION AND SIZE in widgets (e.g. Arc).   </p> <ul> <li>Left - Move widgets left and right.</li> <li>Top - Move widgets up and down.</li> <li>Width - Set the width of widgets.</li> <li>Height - Set the height of widgets.  SPECIFIC in WIDGETS (e.g. Arc) to change the way it is displayed. SPECIFIC has different items that can be changed depending on the widgets displayed.   </li> <li>Range min - Minimum value of range</li> <li>Range max - Maximum value of range</li> <li>Value - Length of the blue line (depends on the application.)</li> <li>Bg start angle - Starting point of the blue line</li> <li>Bg end angle - End of the blue line</li> <li>Mode - Select from three types.  NORMAL appears at the fixed position of the blue line, SYMMETRICAL at the symmetrical position of the fixed position of the blue line, and REVERSE at the exact opposite position of the fixed position of the blue line.</li> </ul> </li> <li> <p>Adding image files Click on bitmaps on the right and drag and drop image files from Explorer into the red box.   </p> </li> <li> <p>Apply image to widgets (image). Drag and drop the necessary widgets (image) from the Components Palettes.     Add the image files added in Add Image Files.   </p> </li> <li> <p>Apply image to widgets (imagebutton). Drag and drop the necessary widgets (imagebutton) from the Components Palettes.     Add the image files added in Add Image Files.   </p> </li> </ol>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#generating-c-source-code","title":"Generating C source code","text":"<ol> <li> <p>Open the created UI project in EEZ Studio   </p> </li> <li> <p>Generate source code by following the steps below.</p> <ul> <li> <p>2.1. Preservation</p> </li> <li> <p>2.2. Check the settings.</p> </li> <li> <p>2.3. Build and generate source code </p> </li> </ul> </li> <li> <p>Source code is generated. Source files are generated in the source folder in the project within eez-project.   </p> </li> </ol>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#implementation-of-events","title":"Implementation of events","text":"<ol> <li> <p>Follow the steps below to set up events using the UI in EEZ Studio.</p> <ol> <li> <p>Press \"+\" for \"event handlers\" in the properties of the object for which you want to set events. </p> </li> <li> <p>Select \"New Action\" and set the event name. </p> </li> <li> <p>Go to \"User Actions\", select the event created in the previous step, and copy the generated event callback template to screen.c. </p> </li> </ol> </li> <li> <p>Implement the generated event callback in C language. In this example, color of the button is changed in the event callback function.</p> </li> </ol> <pre><code>void action_push(lv_event_t *e) {\n\tlv_obj_t btn = lv_event_get_target(e);\n\n\tlv_obj_set_style_bg_color(btn, lv_color_hex(0xfff6e01d), LV_PART_MAIN | LV_STATE_DEFAULT);\n}\n</code></pre>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#implementation-of-screen-transitions","title":"Implementation of screen transitions","text":"<ul> <li> <p>For screen transitions, a screen ID is assigned to each page in screen.h when a multi-page UI is created in EEZ Studio. </p>screen.h<pre><code>enum ScreensEnum {\n\tSCREEN_ID_MAIN = 1,\n\tSCREEN_ID_SECOND = 2,\n};\n</code></pre> </li> <li> <p>To perform screen transitions, implement them in the event callbacks by yourself using the C language. In this example, screen transition is implemented in an event callback is. </p><pre><code>void action_push(lv_event_t *e) {\n\tloadScreen(SCREEN_ID_SECOND);\n}\n</code></pre> </li> </ul>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#2-build-lvgl-gui-applications","title":"2. Build LVGL GUI applications","text":"<p>You can build LVGL GUI applications from the generated source code. Please note that you need to build the applications on a Linux PC.</p>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#setting-up-cross-compiler","title":"Setting up cross compiler","text":"<p>Install cross compiler to your Linux PC, and enable the compiler. To install and enable the compiler, see Step 1: Build Sample Applications.</p>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#building-gui-application","title":"Building GUI application","text":"<ol> <li> <p>Add \"main.c\" to the generated \u201csrc/ui folder. An example of main.c is shown in Appendix.</p> </li> <li> <p>Create a Makefile in the generated \"src/ui folder\" and execute make command. An example of MakeFile is shown in Appendix.</p> </li> </ol>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#3-deploy-and-run-lvgl-gui-applications","title":"3. Deploy and run LVGL GUI applications","text":"<p>Copy the built executable file into a microSD card so that you can run it on the EVK.</p>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#checking-operation-of-the-application-on-evk","title":"Checking operation of the application on EVK","text":"<ol> <li> <p>Copy the generated executable file to the root filesystem in an SD card. For information about how to copy the file, see Step 2: Deploy Sample Applications.</p> </li> <li> <p>Set execute permission on the file. </p><pre><code>chmod +x &lt;executable file name&gt;\n</code></pre> </li> <li> <p>Execute the file. </p><pre><code>./&lt;executable file name&gt;\n</code></pre> </li> </ol> <p></p>"},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#appendix","title":"Appendix","text":""},{"location":"wiki/lvgl_develop-hmi-using-eez-studio/#sample-source-code","title":"Sample source code","text":"main.c<pre><code>#include &lt;unistd.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;limits.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;poll.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;getopt.h&gt;\n\n#include \"lvgl/lvgl.h\"\n#include \"lvgl/lv_drivers/lv_drv_conf.h\"\n\n/* Added to run EEZ Studio generated source code */\n#include \"ui.h\"\n\n#if  USE_FBDEV &amp;&amp; USE_EVDEV\n #undef  RUNS_ON_WAYLAND\n#elif USE_WAYLAND\n #define RUNS_ON_WAYLAND\n#else\n #error  LVGL drivers configuration error.\n#endif\n\n#ifdef RUNS_ON_WAYLAND\n #include \"lvgl/lv_drivers/wayland/wayland.h\"\n#else\n#include \"lvgl/lv_drivers/display/fbdev.h\"\n#include \"lvgl/lv_drivers/indev/evdev.h\"\n\ntypedef struct {\n\tlv_coord_t width;\n\tlv_coord_t height;\n\tbool end;\n\tlv_color_t *buff;\n\tlv_disp_draw_buf_t draw_buf;\n\tlv_disp_drv_t drv;\n\tlv_disp_t *disp;\n\tlv_indev_drv_t indev_drv;\n\tlv_indev_t *mouse_indev;\n} dispinf_fbevdev_t;\n#endif /* RUNS_ON_WAYLAND */\n\n#define\tMAX_JSON_ARR\t8\n#define\tWINDOW_WIDTH\t640\n#define\tWINDOW_HEIGHT\t480\n\n#ifndef RUNS_ON_WAYLAND\n\n/* Create fbdev window with evdev */\nstatic dispinf_fbevdev_t *create_fbdev_window()\n{\n\tuint32_t width, height;\n\tdispinf_fbevdev_t *dispinf;\n\tlv_disp_drv_t *disp_drv;\n\tlv_obj_t *cursor_obj;\n\tbool ret;\n\n\t/* Init Linux frame buffer device for LVGL */\n\tfbdev_init();\n\tfbdev_get_sizes(&amp;width, &amp;height, NULL);\n\n\tdispinf = lv_mem_alloc(sizeof (dispinf_fbevdev_t));\n\tif (!dispinf) {\n\t\tprintf(\"ERROR!! memory allocation failed at lv_mem_alloc()\\n\");\n\t\treturn NULL;\n\t}\n\n\tdispinf-&gt;buff = lv_mem_alloc(width * height * sizeof(lv_color_t));\n\tif (!dispinf-&gt;buff) {\n\t\tprintf(\"ERROR!! memory allocation failed at lv_mem_alloc()\\n\");\n\t\tlv_mem_free(dispinf);\n\t\treturn NULL;\n\t}\n\tlv_disp_draw_buf_init(&amp;dispinf-&gt;draw_buf, dispinf-&gt;buff, NULL,\n\t\t\t\t\t\t\twidth * height);\n\n\tdisp_drv = &amp;dispinf-&gt;drv;\n\t/* Initialize and register a display driver */\n\tlv_disp_drv_init(disp_drv);\n\n\tdisp_drv-&gt;draw_buf   = &amp;dispinf-&gt;draw_buf;\n\tdisp_drv-&gt;flush_cb   = fbdev_flush;\n\tdisp_drv-&gt;hor_res   = (lv_coord_t)width;\n\tdisp_drv-&gt;ver_res   = (lv_coord_t)height;\n\tdisp_drv-&gt;physical_hor_res = (lv_coord_t)width;\n\tdisp_drv-&gt;physical_ver_res = (lv_coord_t)height;\n\n\tdispinf-&gt;disp = lv_disp_drv_register(disp_drv);\n\n\tdispinf-&gt;width = (lv_coord_t)width;\n\tdispinf-&gt;height = (lv_coord_t)height;\n\n\t/* Init evdev for LVGL */\n\tevdev_init();\n\n\tlv_indev_drv_init(&amp;dispinf-&gt;indev_drv);\n\n\tdispinf-&gt;indev_drv.type = LV_INDEV_TYPE_POINTER;\n\t/* This function will be called periodically (by the library)\n\tto get the mouse position and state */\n\tdispinf-&gt;indev_drv.read_cb = evdev_read;\n\n\tdispinf-&gt;mouse_indev = lv_indev_drv_register(&amp;dispinf-&gt;indev_drv);\n\n\t/* Set a cursor for the mouse */\n\tLV_IMG_DECLARE(mouse_cursor);\n\t/* Create an image object for the cursor */\n\tcursor_obj = lv_img_create(lv_scr_act());\n\tlv_img_set_src(cursor_obj, &amp;mouse_cursor);\n\t/* Connect the image object to the driver */\n\tlv_indev_set_cursor(dispinf-&gt;mouse_indev, cursor_obj);\n\n\treturn dispinf;\n}\n\nstatic void close_fbdev_window(dispinf_fbevdev_t *dispinf)\n{\n\tif (!dispinf) {\n\t\tprintf(\"ERROR!! no object to be freed.\\n\");\n\t\treturn;\n\t}\n\n\tif (dispinf-&gt;mouse_indev)\n\t\tlv_indev_delete(dispinf-&gt;mouse_indev);\n\n\tif (dispinf-&gt;disp)\n\t\tlv_disp_remove(dispinf-&gt;disp);\n\n\tif (dispinf-&gt;buff)\n\t\tlv_mem_free(dispinf-&gt;buff);\n\n\tlv_mem_free(dispinf);\n\n\tfbdev_exit();\n}\n#endif\n\nint main(int argc, char *argv[])\n{\n#ifdef RUNS_ON_WAYLAND\n\tstruct pollfd pfd;\n\tuint32_t time_till_next;\n\tint sleep;\n\tlv_disp_t *disp;\n#else /* FBDEV and EVDEV */\n\tdispinf_fbevdev_t *disp;\n#endif\n\tint32_t window_width = WINDOW_WIDTH;\n\tint32_t window_height = WINDOW_HEIGHT;\n\tint32_t ret = 0;\n\n\tint btn_cnt = 0;\n\n\t/*LVGL init*/\n\tlv_init();\n\n#ifdef RUNS_ON_WAYLAND\n\tlv_wayland_init();\n\n\tdisp = lv_wayland_create_window(window_width,window_height,\n\t\t\t\t\t\"Window Demo\", NULL);\n\tif (disp == NULL) {\n\t\tprintf(\"ERROR!! lv_wayland_create_window\\n\");\n\t\tgoto APP_EXIT;\n\t}\n\n\tpfd.fd = lv_wayland_get_fd();\n\tpfd.events = POLLIN;\n\n#else /* FBDEV and EVDEV */\n\tdisp = create_fbdev_window();\n\tif (disp == NULL) {\n\t\tprintf(\"ERROR!! lv_wayland_create_window\\n\");\n\t\tgoto APP_EXIT;\n\t}\n\t/* Clear end flag */\n\tdisp-&gt;end = false;\n\twindow_width = disp-&gt;width;\n\twindow_height = disp-&gt;height;\n#endif\n\n\t/* make_screen */\n\t/*Added to run EEZ Studio generated source code */\n\tui_init();\n\n\twhile(1) {\n#ifdef RUNS_ON_WAYLAND\n\t\t/* Handle any Wayland/LVGL timers/events */\n\t\ttime_till_next = lv_wayland_timer_handler();\n\n\t\t/* Run until the last window closes */\n\t\tif (!lv_wayland_window_is_open(NULL)) {\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Wait for something interesting to happen */\n\t\tif (time_till_next == LV_NO_TIMER_READY) {\n\t\t\tsleep = -1;\n\t\t} else if (time_till_next &gt; INT_MAX) {\n\t\t\tsleep = INT_MAX;\n\t\t} else {\n\t\t\tsleep = time_till_next;\n\t\t}\n\t\twhile ((poll(&amp;pfd, 1, sleep) &lt; 0) &amp;&amp; (errno == EINTR));\n#else /* FBDEV and EVDEV */\n\t\tlv_timer_handler();\n\t\tusleep(5000);\n\t\tif (disp-&gt;end)\n\t\t\tbreak;\n#endif\n\t}\n\nAPP_EXIT:\n\n#ifdef RUNS_ON_WAYLAND\n\tlv_wayland_deinit();\n\n#else /* FBDEV and EVDEV */\n\tclose_fbdev_window(disp);\n#endif\n\treturn 0;\n}\n/**\n* Set in lv_conf.h as `LV_TICK_CUSTOM_SYS_TIME_EXPR`\n*/\nuint32_t custom_tick_get(void)\n{\n\tstatic uint64_t start_ms = 0;\n\tstruct timeval tv_start;\n\tstruct timeval tv_now;\n\tuint64_t now_ms;\n\n\tif(start_ms == 0) {\n\t\tgettimeofday(&amp;tv_start, NULL);\n\t\tstart_ms = (tv_start.tv_sec * 1000000 + tv_start.tv_usec) / 1000;\n\t}\n\tgettimeofday(&amp;tv_now, NULL);\n\tnow_ms = (tv_now.tv_sec * 1000000 + tv_now.tv_usec) / 1000;\n\n\treturn (uint32_t)(now_ms - start_ms);\n}\n</code></pre> Makefile<pre><code>BIN = EEZ_sample\nCFLAGS += -I${SDKTARGETSYSROOT}/usr/include/lvgl -I${SDKTARGETSYSROOT}/usr/include/lvgl/lv_drivers -DLV_CONF_INCLUDE_SIMPLE\nLDFLAGS += -llvgl -llv_drivers -lwayland-client\nSRC_DIR := ./ui\nMAIN := $(SRC_DIR)/main.c\nSRCS := $(shell find $(SRC_DIR) -name '*.c' ! -name 'main.c')\nMAINOBJ = $(MAIN:.c=.o)\nOBJS := $(SRCS:$(SRC_DIR)/%.c=$(SRC_DIR)/%.o)\n.PHONY: all clean\nall: default\n%.o: %.c\n\t@$(CC) $(CFLAGS) -c $&lt; -o $@\ndefault: $(OBJS) $(MAINOBJ)\n\t$(CC) -o $(BIN) $(MAINOBJ) $(OBJS) $(LDFLAGS)\nclean:\n\t@echo \"Cleaning ... \"\n\trm -f $(BIN) $(MAINOBJ) $(OBJS)\n</code></pre>"}]}